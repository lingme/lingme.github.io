{"pages":[],"posts":[{"title":"AllocConsole 重定向控制台使用","text":"在软件开发的过程中，我们有时候可能需要日志和输出帮助我们进行 Debug 和 Review，尤其是 .NET C# 开发中，我们调试经常需要输出各种信息，当我们使用 IDE 为 Visual Studio 的时候，VS 自带的输出没有我们自己开一个控制台那般阅读方便，所以我们可以使用 AllocConsole 重定向控制台。 1 . 引用12345678910111213141516171819202122232425262728293031public class ConsoleWindow{ [DllImport(&quot;kernel32.dll&quot;)] private static extern bool AllocConsole(); [DllImport(&quot;kernel32.dll&quot;)] private static extern bool FreeConsole(); [DllImport(&quot;kernel32.dll&quot;)] private static extern IntPtr GetConsoleWindow(); [DllImport(&quot;kernel32.dll&quot;)] private static extern int GetConsoleOutputCP(); public static bool HasConsole { get { return GetConsoleWindow() != IntPtr.Zero; } } public static void Show() { if (!HasConsole) { AllocConsole(); } } public static void Close() { if (HasConsole) { SetOutAndErrorNull(); FreeConsole(); } }} 我们需要引用 Kernel32.dll 这个动态链接库文件中包含了 Windows 常见的内存管理、数据的输入输出操作和中断处理 2 . 启动我们以 WPF 为例，我们可以重写App级的视图类来达到启动 WPF 程序的时候自动打开AllocConsole控制台。 {.line-numbers}12345678protected override void OnStartup(StartupEventArgs e){ base.OnStartup(e); #if DEBUG Common.Utility.ConsoleWindow.Show(); #endif} 我们可以重写 OnStartup 方法，达到启动 WPF 程序的时候自动启动一个AllocConsole，这里我们用了一个 #if DEBUG，代表只在 Debug 调试模式下启动 3 . 设置程序输出类型 设置自己程序的 输出类型 — 控制台应用程序 4 . 输出1Console.WriteLine() 使用控制台输出命令输出需要调试的日志和状态了，当然这里只是列举了输出，一切关于控制台的控制在引用AllocConsole以后都会表现出来。AllocConsole 控制台在应用程序退出的时候将会自动结束，当然你也可以调用 Close() 方法在任意时间结束。","link":"/2017/01/02/AllocConsole/"},{"title":"Avalonia 体验","text":"最近在做跨平台（Mac OS 和 Windows）的项目，虽然最终采用了 QT 和 C++ 的组合，但是依然试水一下 Avalonia ，毕竟是 Star 了好几年的跨平台 WPF 框架，因为之前一直没有跨 Mac OS 的需求，所以一直在用 Windows 平台下的 .NET WPF，今天来看看 Avalonia 跨平台 WPF 的体验吧。 1.安装 Avalonia Template第一步肯定是要安装 Avalonia 的项目模版了，这样可以为 dotnet cli 提供快速创建项目的能力。 1.去下面的 github 地址把 Avalonia 模板 clone 下来： https://github.com/AvaloniaUI/avalonia-dotnet-templates 2.执行安装命令，将 Avalonia 模板安装到 dotnet cli。 dotnet new –install [path-to-repository] path-to-repository 就是你 clone 下来的地址，安装结束以后，dotnet cli 回列出当前系统中所有可供选择的模板。 2.创建第一个 Avalonia 项目因为我们已经安装了 Avalonia 的项目模板，所以直接运行创建模板的命令： dotnet new avalonia.mvvm -o QuickAvalonia 没有问题的话，会看到 The template “Avalonia .NET Core MVVM App” was created successfully. 这样我们就创建了我们的第一个 Avalonia 项目， 3.运行第一个 Avalonia 项目因为使用官方的模板创建的，所以已经内置了 Hello World，我们可以直接通过运行命令跑起来. dotnet run 4.解析 Avalonia 项目结构开发体验还不错，简单的几个命令就创建了一个跨平台的 WPF 架构软件，我们开始试水体验一下，不过在这之前我们先解析一下项目结构。 Dependencies 依赖的 Dotnet 框架，我这里是是 Dotnet 3.1.201 Assets 资源文件，这里放了一个 ico，用作软件的图标 Models 空文件夹，Avalonia 官方预设的文件夹，以后咱们的业务模型可以放到这里 ViewModels 放置 VM 的文件夹，里头已经有两个预设了，可以看到 MainWindowViewModel 和 ViewModelBase。 MainWindowViewModel 123456789101112using System;using System.Collections.Generic;using System.Text;namespace QuickAvalonia.ViewModels{ public class MainWindowViewModel : ViewModelBase { public string Greeting =&gt; &quot;Hello World!&quot;; }} 有一个 CLI 封装属性，用于在窗口显示 binding 的 Hello world。 ViewModelBase 123456789101112using System;using System.Collections.Generic;using System.Text;using ReactiveUI;namespace QuickAvalonia.ViewModels{ public class ViewModelBase : ReactiveObject { }} 所有的 viewmodel 继承这个 ViewModelBase，然后他继承了 ReactiveOjbect，这个是 Avalonia 的内置类，做过 WPF 的人都知道，MVVM 模式，所有具备通知 UI 的属性，都需要继承 INotifyPropertyChange 接口，所以这个 ReactiveOjbect 应该是也是实现了 INotifyPropertyChange 接口的基类，而且看 MainWindowViewModel 里头属性封装如此简洁，ReactiveOjbect 应该还实现了 AOP ，可以让我们不用像常规封装属性那种麻烦的写法，如果没有实现 AOP，常规的写法应该是这样： 12345678910private Rect _RectLeft;public Rect RectLeft{ get { return _RectLeft; } set { _RectLeft = value; NotifyChanged(() =&gt; RectLeft); }} 这是常规具备 UI 通知属性的封装写法，所以 Avalonia 可以写得如此简洁应该就是实现了 AOP，我们继续往下看。 Views 视图，有一个主窗口，内容只有一个 1&lt;TextBlock Text=&quot;{Binding Greeting}&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt; 用于显示文件，同时也是绑定了 MainWIndowViewModel App 管理我们应用程序的注入还有主窗口配置的工作 Program 启动项目的主入口，有 bug 信息的输出，还有管理 app 生命周期，以及注入 Avalonia UI 框架的工作 ViewLocator 1234567891011121314151617181920212223242526272829303132333435// Copyright (c) The Avalonia Project. All rights reserved.// Licensed under the MIT license. See licence.md file in the project root for full license information.using System;using Avalonia.Controls;using Avalonia.Controls.Templates;using QuickAvalonia.ViewModels;namespace QuickAvalonia{ public class ViewLocator : IDataTemplate { public bool SupportsRecycling =&gt; false; public IControl Build(object data) { var name = data.GetType().FullName.Replace(&quot;ViewModel&quot;, &quot;View&quot;); var type = Type.GetType(name); if (type != null) { return (Control)Activator.CreateInstance(type); } else { return new TextBlock { Text = &quot;Not Found: &quot; + name }; } } public bool Match(object data) { return data is ViewModelBase; } }} 视图寻址器，根据 ViewModels 里头的类去匹配他的视图，他会把地址的 ViewModels，替换成 Views，然后找到 VIewModel 对应的 View。 项目结构就是这样了，如果搞过 WPF MVVM 的开发者应该看到之后很情切友好，这是一个具备的数据驱动以及 AOP 架构的 WPF，开发体验是非常不错的，现在我们做一点修改，把显示的文字换了，把字体加大，背景颜色换掉，来体验一下 Avalonia 的开发体验。 5. 初步体验1.修改显示的文字 1public string Greeting =&gt; &quot;My First Avalonia&quot;; 2.修改字体大小 12&lt;TextBlock FontSize=&quot;60&quot; Text=&quot;{Binding Greeting}&quot; HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;/&gt; 3.修改背景颜色 1Background=&quot;Red&quot; 再次运行 6.总结技术方面就不讨论了，做过 WPF 的开发者应该都了解，我们只说跨平台的体验，虽然没有去下载和体验跨平台的 xmal 设计器 AvaloniaStudio，但是体验依然还是非常不错，数据驱动，AOP，自动 view 寻址，快速创建项目等等，都非常不错，不过不知道异形窗口的体验如何，改天我再写一篇关于 Avalonia 异形窗口构建的体验。","link":"/2020/04/30/AvaloniaHelloWorld/"},{"title":"依赖属性解析","text":"Windows Presentation Foundation (WPF) 提供了一组服务，这些服务可用于扩展公共语言运行时 (CLR) 属性的功能，这些服务通常统称为 WPF 属性系统。由 WPF 属性系统支持的属性称为依赖项属性，虽然不清楚依赖属性，但是属性我们是很清楚的，封装类的字段，表示类的状态，编译后被转化为get_，set_方法，可以被类或结构等使用，常见的一个属性如下： 123456789public class ClassObject { private string name; public string Name { get { return name; } set { name = value; } } } 既然已经有了属性，为什么还要有依赖属性呢？必然是属性有一些缺点了，而依赖属性恰好能够解决这个问题。以 Button 为例: 每次继承，父类的私有字段都被继承下来。对 Button 来说，大多数属性并没有被修改，仍然保持父类定义时的默认值。通常情况下，在整个 Button 的对象生命周期中，也只有少部分属性被修改。也已看得出来： 每次继承，子类对象都会获得更多的属性，这样，继承树的低端对象不可避免的膨胀；既然大多数属性没有被修改，那么就可以把这些属性从对象中剥离，减少对象的体积；可以知道，依赖属性就是为了解决这个问题诞生了。首先定义依赖属性，它里面存储之前 2 中希望剥离的属性： 12345678910111213141516171819202122public class DependencyProperty { // 维护了一个全局的Map用来储存所有的DP internal static Dictionary&lt;object, DependencyProperty&gt; RegisteredDps = new Dictionary&lt;object, DependencyProperty&gt;(); internal string Name;//注册属性名称 internal object Value;//属性值 internal object HashCode;//Mape唯一键值 private DependencyProperty(string name, Type propertyName, Type ownerType, object defaultValue) { this.Name = name; this.Value = defaultValue; this.HashCode = name.GetHashCode() ^ ownerType.GetHashCode(); } // 对外暴露一个Register方法用来注册新的DP public static DependencyProperty Register(string name, Type propertyName, Type ownerType, object defaultValue) { DependencyProperty dp = new DependencyProperty(name, propertyName, ownerType, defaultValue); RegisteredDps.Add(dp.HashCode, dp); return dp; } } 然后定义 DependencyObject 来使用 DP: 123456789101112131415161718192021222324252627public class DependencyObject { // 注册一个新的DP:NameProperty public static readonly DependencyProperty NameProperty = DependencyProperty.Register(&quot;Name&quot;, typeof(string), typeof(DependencyObject), string.Empty); public object GetValue(DependencyProperty dp) { return DependencyProperty.RegisteredDps[dp.HashCode].Value; } public void SetValue(DependencyProperty dp, object value) { DependencyProperty.RegisteredDps[dp.HashCode].Value = value; } public string Name { get { return (string)GetValue(NameProperty); } set { SetValue(NameProperty, value); } } } DependencyObject 和文章开篇的 ClassObject 中的 Name 有什么不同呢？ DependencyObject.Name 的实际值不是用字段保存在 DependencyObject 中，而是保存在 NameProperty 中，通过 SetValue 和 GetValue 来金星赋值取值操作。 在上述例子中，所有 DependncuObject 的对象将共用一个 NameProperty，这在现实中是不实际的：只要修改一个对象的属性，相当于所有对象的属性值都被修改了。所以，修改的属性，还是要维护在相应的对象中的：（修改部分用 ☆ 表示） 123456789101112131415161718192021222324252627public class DependencyProperty { private static int globalIndex = 0;// ☆ // 维护了一个全局的Map用来储存所有的DP internal static Dictionary&lt;object, DependencyProperty&gt; RegisteredDps = new Dictionary&lt;object, DependencyProperty&gt;(); internal string Name;//注册属性名称 internal object Value;//属性值 internal int Index;// ☆ internal object HashCode;//Mape唯一键值 private DependencyProperty(string name, Type propertyName, Type ownerType, object defaultValue) { this.Name = name; this.Value = defaultValue; this.HashCode = name.GetHashCode() ^ ownerType.GetHashCode(); } // 对外暴露一个Register方法用来注册新的DP public static DependencyProperty Register(string name, Type propertyName, Type ownerType, object defaultValue) { DependencyProperty dp = new DependencyProperty(name, propertyName, ownerType, defaultValue); globalIndex++;// ☆ dp.Index = globalIndex; // ☆ RegisteredDps.Add(dp.HashCode, dp); return dp; } } 所有修改过的 DP 都保存在 EffectiveValueEntry 里，这样，就可以只保存修改的属性，未修改过的属性仍然读取 DP 的默认值，优化了属性的储存。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class DependencyObject { // 引入有效的概念// ☆ private List&lt;EffectiveValueEntry&gt; _effectiveValues = new List&lt;EffectiveValueEntry&gt;(); // 注册一个新的DP:NameProperty public static readonly DependencyProperty NameProperty = DependencyProperty.Register(&quot;Name&quot;, typeof(string), typeof(DependencyObject), string.Empty); public object GetValue(DependencyProperty dp) { // ☆ EffectiveValueEntry effectiveValue = _effectiveValues.FirstOrDefault(i =&gt; i.PropertyIndex == dp.Index); if (effectiveValue.PropertyIndex != 0) { return effectiveValue.Value; } else { return DependencyProperty.RegisteredDps[dp.HashCode].Value;//仅此部分相同 } } public void SetValue(DependencyProperty dp, object value) { // 全部 ☆ EffectiveValueEntry effectiveValue = _effectiveValues.FirstOrDefault(i =&gt; i.PropertyIndex == dp.Index); if (effectiveValue.PropertyIndex != 0) { effectiveValue.Value = value; } else { effectiveValue = new EffectiveValueEntry() { PropertyIndex = dp.Index, Value = value }; } //DependencyProperty.RegisteredDps[dp.HashCode].Value = value; } public string Name { get { return (string)GetValue(NameProperty); } set { SetValue(NameProperty, value); } } } 12345internal struct EffectiveValueEntry { internal int PropertyIndex{get;set;} internal object Value{get;set;} }","link":"/2017/05/10/DependencyProperty/"},{"title":"DependencyProperty 属性之事件","text":"依赖属性提供一种全局内部属性存储来在运行时支持应用内的所有依赖属性，从而扩展基本的 Windows 运行时属性功能。这种方法可以替代为具有专用字段的属性（在属性定义类中为专用）提供支持的标准模式。你可以将此内部属性存储视为任何特定对象的一组属性标识符和值（只要该对象是 DependencyObject 即可）。属性存储中的每个属性均通过 DependencyProperty 实例（而不是通过名称）进行标识。但是，大多数情况下，属性系统会隐藏该实现详细信息：你可以使用简单名称频繁访问依赖属性。 1public static DependencyProperty Register(string name, Type propertyType, Type ownerType, PropertyMetadata typeMetadata, ValidateValueCallback validateValueCallback); Register重载方法最多提供了三种回调： 类 型 说 明 ValidateValueCallback 验证回调 PropertyChangedCallback 值改变回调 CoerceValueCallback 强制转化回调 下面我们来研究一下这三种回调的优先级和作用： 首先写一个父类： 1234567891011121314151617181920212223public class TestDe:DependencyObject { public int TestInt { get { return (int)GetValue(TestInt_Property); } set { SetValue(TestInt_Property, value); } } public static readonly DependencyProperty TestInt_Property = DependencyProperty.Register (&quot;TestInt&quot;, typeof(int), typeof(TestDe), new PropertyMetadata(100, PropertyChanged, Coerce) , Validate); static void PropertyChanged(DependencyObject dobj, DependencyPropertyChangedEventArgs e) { Console.WriteLine(String.Format(&quot;PropertyChanged：{0} NewValue：{1} OldValue：{2}&quot;, e.Property.Name, e.NewValue, e.OldValue)); } static object Coerce(DependencyObject dobj, object newValue) { Console.WriteLine(String.Format(&quot;Coerce - {0}&quot;, newValue)); return newValue; } static bool Validate(object obj) { Console.WriteLine(String.Format(&quot;Validate - {0}&quot;, obj)); return true; } } 然后实例化这个类： 12345static void Main(string[] args) { TestDe Anti = new TestDe(); Console.ReadLine(); } 我们会发现，验证回调事件被执行了两遍，这是因为 实例化TestDe这个类的时候（因为int初始值为0），被验证了一次了，然后我们的注册函数给初始值的100的时候又验证了一次。 继续探索，我们开始修改这个对象的属性： 123456static void Main(string[] args) { TestDe Anti = new TestDe(); Anti.TestInt = 300; Console.ReadLine(); } 这次一共输出了5个条目，前两条前面已经说过了，我们开始解释后面。 ▲Validate - 300 这个是我们实例化之后修改属性值触发的验证回调事件▲Coerce - 300 这个是强制转化的回调触发事件，为什么要一定要触发这个事件呢？查询MSDN发现： img因为属性值在赋值的时候，可能是通过一些函数方法触发的，比如Parse之类的，他们的类型是一个string，所以依赖属性会触发这个强制转换。 ▲PropertyChanged: TestInt NewValue : 300 OldaValue：100 这个就不用说了，核心部分，就是当属性值改变的时候会触发的回调方法。 那么这个触发链可以看成是 验证 —》 强制转换 —》属性值改变回调 下面我研究的就是属性值的改变，验证回调的触发和规则：、首先我们更改一下验证回调： 我们发现会触发ArgumentException异常，提示300不是TestInt的有效值，因为我们在回调验证函数里面写了 如果大于 300 则 返回 false 接下来我们研究一下子类重写父类的这些回调会发生什么： 123456789101112131415public class TestChild:TestDe { static TestChild() { TestDe.TestInt_Property.OverrideMetadata(typeof(TestChild), new PropertyMetadata(99, PropertyChanged, Coerce)); } static void PropertyChanged(DependencyObject dobj, DependencyPropertyChangedEventArgs e) { Console.WriteLine(String.Format(&quot;TestChild Class - PropertyChanged：{0} NewValue：{1} OldValue：{2}&quot;, e.Property.Name, e.NewValue, e.OldValue)); } static object Coerce(DependencyObject dobj, object newValue) { Console.WriteLine(String.Format(&quot;TestChild Class - Coerce - {0}&quot;, newValue)); return newValue; } } 实例化： 我们会发现，父类，子类验证都会触发 我们更改子类的依赖属性值试试： 子类和父类的验证和属性改变回调都会依次被调用，但是强制转换只调用子类的。","link":"/2017/05/03/DependencyPropertyEvent/"},{"title":".NET 5.0 Source Generators","text":"Source Generators 目前还属于 Preview 状态 随着.NET 5 正式版的发布，我相信.NET 社区以及使用.NET 技术栈的工程师们已迎来新血液，.NET 5 发布了诸多新功能，例如：Top-level programs，这让我们可以像写脚本语言一样，不用需要声明命名空间和类，直接开写。新一代 GC，更高的编译性能，Dictionary&lt;K,V&gt;的匿名声明支持等等，其中有一项功能我在预览版就已经用于我的项目，并且解决了非常大的痛点，这项功能就是 Source Generators 简介Source Generators 直接翻译就是代码生成器，源代码生成器是一段在编译过程中运行的代码，可以检查您的程序以生成与其他代码一起编译。使用 Source Generators，可以做到这些事情： 检索一个表示所有正在编译的用户代码的 Compilation 对象。可以检查此对象，并且您可以编写与正在编译的代码的语法和语义模型一起使用的代码。 生成可在编译过程中添加到 Compilation 对象的 C＃源文件。换句话说，可以在编译代码时提供其他源代码作为编译的输入 应用方向拿 ASP.NET Core 举例，启动一个 ASP.NET Core 应用时，首先会通过运行时反射来发现 Controllers、Services 等的类型定义，然后在请求管道中需要通过运行时反射获取其构造函数信息以便于进行依赖注入。 然而运行时反射开销很大，即使缓存了类型签名，对于刚刚启动后的应用也无任何帮助作用，而且不利于做 AOT 编译。 什么是 AOT 在计算机科学中，提前编译（AOT 编译）是编译更高级编程语言（如 C 或 C ++）或中间代码（如 Java 字节码或.NET Framework 通用中间语言（CIL）代码），转换为本机（系统相关的）机器代码，以便生成的二进制文件可以本机执行的行为。 这是 Wiki 的解释，简单而言就是，AOT 会把咱们写的高级语言编译成介乎机器代码之间的一层语言，并且会把我们的代码进行优化。 Source Generators 和 AOTSource Generators 的另一个特点是，它们可以帮助消除基于链接器和 AOT（提前）编译优化的主要障碍。许多框架和库都大量使用反射或反射发射，例如 System.Text.Json，System.Text.RegularExpressions 以及诸如 ASP.NET Core 和 WPF 之类的框架，它们在运行时从用户代码中发现和/或发出类型。 人们在使用许多顶级 NuGet 软件包时会大量使用反射来在运行时发现类型。集成这些软件包对于大多数.NET 应用程序至关重要，因此，代码的“可链接性”和使用 AOT 编译器优化的能力将受到极大影响。 项目实践作为.NET 程序员，大家一定写过 WPF 或者 UWP，在 ViewModel 中为了使属性变更可被发现，需要实现 INotifyPropertyChanged 接口，并且在每一个需要的属性的 Setter 处触发属性更改事件 他大概是这个样子 1234567891011121314class ViewModel : INotifyPropertyChanged{ public event PropertyChangedEventHandler? PropertyChanged; private string _title; public string Title { get =&gt; _title; set { _title = value; PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(Title))); } }} 然后视图绑定 1&lt;TextBlock Text=&quot;{Binding Title}&quot;&gt;&lt;/TextBlock&gt; 因为 Title 字段实现了 PropertyChanged，所以我们在 ViewModel 中改变 Title 的值，那视图中的 TextBlock 的 Text 也会实时更新。看起来非常不错，视图和 VM 分离，但是问题来了，在实际的业务中，我们的 GUI 会非常复杂，需要非常多的字段去驱动这个 GUI，那么为了响应更改通知，我们的每一个字段都需要这样封装，这非常非常痛苦，虽然有一些库可以帮我解决痛点，比如 PropertyChange，只需要一个 Attribute，即可解决声明问题，他的写法类似于这样： 123456[AddINotifyPropertyChangedInterface]class ViewModel{ public string Title; public int Count;} 这样在编译的时候这个框架会自动加入 IL 编织代码，去帮我们实现 PropertyChanged 的属性声明 但是对于喜欢造轮子的程序员来说，我们还喜欢自己造一个，那接下来我们就会利用.NET 5 的新特性 Source Generators 来制造这么一个东西，帮我们自动封装响应字段。 前期准备和检查为了使用 Source Generators，我们需要引入两个包 Microsoft.CodeAnalysis.CSharp.Workspaces Microsoft.CodeAnalysis.Analyzers 编写 AutoNotify Source Generators我们需要建立一个标准的.NET Standard 2.0 库，然后编写如下代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170using System;using System.Collections.Generic;using System.Linq;using System.Text;using Microsoft.CodeAnalysis;using Microsoft.CodeAnalysis.CSharp;using Microsoft.CodeAnalysis.CSharp.Syntax;using Microsoft.CodeAnalysis.Text;namespace MySourceGenerator{ [Generator] public class AutoNotifyGenerator : ISourceGenerator { private const string attributeText = @&quot; using System; namespace AutoNotify { [AttributeUsage(AttributeTargets.Field, Inherited = false, AllowMultiple = false)] sealed class AutoNotifyAttribute : Attribute { public AutoNotifyAttribute() { } public string PropertyName { get; set; } } } &quot;; public void Initialize(GeneratorInitializationContext context) { context.RegisterForSyntaxNotifications(() =&gt; new SyntaxReceiver()); } public void Execute(GeneratorExecutionContext context) { context.AddSource(&quot;AutoNotifyAttribute&quot;, SourceText.From(attributeText, Encoding.UTF8)); if (!(context.SyntaxReceiver is SyntaxReceiver receiver)) return; CSharpParseOptions options = (context.Compilation as CSharpCompilation).SyntaxTrees[0].Options as CSharpParseOptions; Compilation compilation = context.Compilation.AddSyntaxTrees(CSharpSyntaxTree.ParseText(SourceText.From(attributeText, Encoding.UTF8), options)); INamedTypeSymbol attributeSymbol = compilation.GetTypeByMetadataName(&quot;AutoNotify.AutoNotifyAttribute&quot;); INamedTypeSymbol notifySymbol = compilation.GetTypeByMetadataName(&quot;System.ComponentModel.INotifyPropertyChanged&quot;); List&lt;IFieldSymbol&gt; fieldSymbols = new List&lt;IFieldSymbol&gt;(); foreach (FieldDeclarationSyntax field in receiver.CandidateFields) { SemanticModel model = compilation.GetSemanticModel(field.SyntaxTree); foreach (VariableDeclaratorSyntax variable in field.Declaration.Variables) { IFieldSymbol fieldSymbol = model.GetDeclaredSymbol(variable) as IFieldSymbol; if (fieldSymbol.GetAttributes().Any(ad =&gt; ad.AttributeClass.Equals(attributeSymbol, SymbolEqualityComparer.Default))) { fieldSymbols.Add(fieldSymbol); } } } foreach (IGrouping&lt;INamedTypeSymbol, IFieldSymbol&gt; group in fieldSymbols.GroupBy(f =&gt; f.ContainingType)) { string classSource = ProcessClass(group.Key, group.ToList(), attributeSymbol, notifySymbol, context); context.AddSource($&quot;{group.Key.Name}_autoNotify.cs&quot;, SourceText.From(classSource, Encoding.UTF8)); } } private string ProcessClass(INamedTypeSymbol classSymbol, List&lt;IFieldSymbol&gt; fields, ISymbol attributeSymbol, ISymbol notifySymbol, GeneratorExecutionContext context) { if (!classSymbol.ContainingSymbol.Equals(classSymbol.ContainingNamespace, SymbolEqualityComparer.Default)) { return null; //TODO: issue a diagnostic that it must be top level } string namespaceName = classSymbol.ContainingNamespace.ToDisplayString(); StringBuilder source = new StringBuilder($@&quot; namespace {namespaceName} {{ public partial class {classSymbol.Name} : {notifySymbol.ToDisplayString()} {{ &quot;); if (!classSymbol.Interfaces.Contains(notifySymbol)) { source.Append(&quot;public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;&quot;); } foreach (IFieldSymbol fieldSymbol in fields) { ProcessField(source, fieldSymbol, attributeSymbol); } source.Append(&quot;} }&quot;); return source.ToString(); } private void ProcessField(StringBuilder source, IFieldSymbol fieldSymbol, ISymbol attributeSymbol) { string fieldName = fieldSymbol.Name; ITypeSymbol fieldType = fieldSymbol.Type; AttributeData attributeData = fieldSymbol.GetAttributes().Single(ad =&gt; ad.AttributeClass.Equals(attributeSymbol, SymbolEqualityComparer.Default)); TypedConstant overridenNameOpt = attributeData.NamedArguments.SingleOrDefault(kvp =&gt; kvp.Key == &quot;PropertyName&quot;).Value; string propertyName = chooseName(fieldName, overridenNameOpt); if (propertyName.Length == 0 || propertyName == fieldName) { //TODO: issue a diagnostic that we can't process this field return; } source.Append($@&quot; public {fieldType} {propertyName} {{ get {{ return this.{fieldName}; }} set {{ this.{fieldName} = value; this.PropertyChanged?.Invoke(this, new System.ComponentModel. PropertyChangedEventArgs(nameof({propertyName}))); }} }}&quot;); string chooseName(string fieldName, TypedConstant overridenNameOpt) { if (!overridenNameOpt.IsNull) { return overridenNameOpt.Value.ToString(); } fieldName = fieldName.TrimStart('_'); if (fieldName.Length == 0) return string.Empty; if (fieldName.Length == 1) return fieldName.ToUpper(); return fieldName.Substring(0, 1).ToUpper() + fieldName.Substring(1); } } class SyntaxReceiver : ISyntaxReceiver { public List&lt;FieldDeclarationSyntax&gt; CandidateFields { get; } = new List&lt;FieldDeclarationSyntax&gt;(); / / / public void OnVisitSyntaxNode(SyntaxNode syntaxNode) { if (syntaxNode is FieldDeclarationSyntax fieldDeclarationSyntax &amp;&amp; fieldDeclarationSyntax.AttributeLists.Count &gt; 0) { CandidateFields.Add(fieldDeclarationSyntax); } } } }} 引入依赖，进行测试我们需要把上面编写的 .NET 标准库引入到自己的项目中，引入项目后需要编辑项目文件，然后加入输出项目类型为 Analyzer ，这样才可以识别我们写的 Attribute ，然后标记引用输出编译为 false。 1OutputItemType=&quot;Analyzer&quot; ReferenceOutputAssembly=&quot;false&quot; 然后进行测试 1234567891011121314151617181920212223public partial class ExampleViewModel { [AutoNotify] private string _text = &quot;private field text&quot;; [AutoNotify(PropertyName = &quot;Count&quot;)] private int _amount = 5; }public static class UseAutoNotifyGenerator{ public static void Run() { ExampleViewModel vm = new ExampleViewModel(); string text = vm.Text; Console.WriteLine($&quot;Text = {text}&quot;); int count = vm.Count; Console.WriteLine($&quot;Count = {count}&quot;); vm.PropertyChanged += (o, e) =&gt; Console.WriteLine($&quot;Property {e.PropertyName} was changed&quot;); vm.Text = &quot;abc&quot;; vm.Count = 123; }} Source Generator 自动为我们生成了 Text 和 Count 字段，并且响应了 PropertyChange 通知。","link":"/2020/11/05/Dotnet5SourceGenerators/"},{"title":"Dotnet Consul 服务发现","text":"在分布式架构中，服务治理是必须面对的问题，如果缺乏简单有效治理方案，各服务之间只能通过人肉配置的方式进行服务关系管理，当遇到服务关系变化时，就会变得极其麻烦且容易出错，Consul 是一个用来实现分布式系统服务发现与配置的开源工具。它内置了服务注册与发现框架、分布一致性协议实现、健康检查、Key/Value 存储、多数据中心方案，不再需要依赖其他工具（比如 ZooKeeper 等），使用起来也较为简单。 Consul 架构 Consul 集群支持多数据中心，在上图中有两个 DataCenter，他们通过 Internet 互联，为了提高通信效率，只有 Server 节点才加入跨数据中心的通信。在单个数据中心中，Consul 分为 Client 和 Server 两种节点（所有的节点也被称为 Agent），Server 节点保存数据，Client 负责健康检查及转发数据请求到 Server，本身不保存注册信息；Server 节点有一个 Leader 和多个 Follower，Leader 节点会将数据同步到 Follower，Server 节点的数量推荐是 3 个或者 5 个，在 Leader 挂掉的时候会启动选举机制产生一个新 Leader，接下来我们用 Dotnet 加上 Docker 搭建一个我们自己的服务治理。 Consul 集群搭建1.首先把 Consul 官方镜像拉取下来： docker pull consul 2.启动一个 Client 节点： 1docker run --name cc1 -p 5500:8500 -v /data/cc1:/data consul agent -bind 172.17.0.5 -node consul-client-1 -data-dir /data -client 0.0.0.0 -ui -join 172.17.0.2 3.这里我们搭建三个 service 节点，一个 Leader，两个 Slave。 启动 Leader： 1docker run --name cs1 -p 8500:8500 -v /data/cs1:/data consul agent -server -bind 172.17.0.2 -node consul-server-1 -data-dir /data -bootstrap-expect 3 -client 0.0.0.0 -ui 启动 Slave 1: 1docker run --name cs2 -p 7500:8500 -v /data/cs2:/data consul agent -server -bind 172.17.0.3 -node consul-server-2 -data-dir /data -bootstrap-expect 3 -client 0.0.0.0 -ui -join 172.17.0.2 启动 Slave 2: 1docker run --name cs3 -p 6500:8500 -v /data/cs3:/data consul agent -server -bind 172.17.0.4 -node consul-server-3 -data-dir /data -bootstrap-expect 3 -client 0.0.0.0 -ui -join 172.17.0.2 参数说明： 参数名 解释 –name Docker 容器名称（每个 Consul 节点一个容器） -p 容器内部 8500 端口映射到当前主机端口，因为使用的同一台主机，所以这里每个容器内的 8500 端口映射到当前主机的不同端口 -v 将节点相关注册数据挂载到当前主机的指定位置，否则重启后会丢失，Docker 设置里头给 Sharing 权限 -server 设置为 Server 类型节点，不加则为 Client 类型节点 -bind 指定节点绑定的地址 -node 指定节点名称 -data-dir 数据存放位置 -bootstrap-expect 集群期望的 Server 节点数，只有达到这个值才会选举 Leader -client 注册或者查询等一系列客户端对它操作的 IP，默认是 127.0.0.1 -ui 启用 UI 界面 -join 指定要加入的节点地址（组建集群） 集群组建完成了，我们可以查看 consul 集群的状态。 1.查看节点类型以及状态 docker exec -t cs1 consul members 2.查看 Server 节点类型 docker exec -t cs1 consul operator raft list-peers .NET Core 集成 Consul1.创建一个 WebAPI 程序，我这里命名为 ServiceA 2.Nuget 安装 Consul 包 3.注册 A 节点 123456789101112131415161718192021222324252627282930313233343536public static class ConsulBuilderExtensions{ public static IApplicationBuilder RegisterConsul(this IApplicationBuilder app, IApplicationLifetime lifetime, ConsulOption consulOption) { var consulClient = new ConsulClient(x =&gt; { // consul 服务地址 x.Address = new Uri(consulOption.Address); }); var registration = new AgentServiceRegistration() { ID = Guid.NewGuid().ToString(), Name = consulOption.ServiceName,// 服务名 Address = consulOption.ServiceIP, // 服务绑定IP Port = consulOption.ServicePort, // 服务绑定端口 Check = new AgentServiceCheck() { DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(5),//服务启动多久后注册 Interval = TimeSpan.FromSeconds(10),//健康检查时间间隔 HTTP = consulOption.ServiceHealthCheck,//健康检查地址 Timeout = TimeSpan.FromSeconds(5) } }; // 服务注册 consulClient.Agent.ServiceRegister(registration).Wait(); // 应用程序终止时，服务取消注册 lifetime.ApplicationStopping.Register(() =&gt; { consulClient.Agent.ServiceDeregister(registration.ID).Wait(); }); return app; }} 添加刚刚的节点 12345&quot;ServiceName&quot;: &quot;ServiceA&quot;,&quot;ServiceIP&quot;: &quot;192.168.124.8&quot;,&quot;ServicePort&quot;: 8000,&quot;ServiceHealthCheck&quot;: &quot;http://192.168.124.8:8000/healthCheck&quot;,&quot;ConsulAddress&quot;: &quot;http://192.168.124.8:8500&quot; 4.注册 B 节点，并且调用 A 节点 12345678910111213141516171819var url = _configuration[&quot;ConsulAddress&quot;].ToString();using (var consulClient = new ConsulClient(a =&gt; a.Address = new Uri(url))){ var services = consulClient.Catalog.Service(&quot;ServiceA&quot;).Result.Response; if (services != null &amp;&amp; services.Any()) { Random r = new Random(); int index = r.Next(services.Count()); var service = services.ElementAt(index); using (HttpClient client = new HttpClient()) { var response = await client.GetAsync($&quot;http://{service.ServiceAddress}:{service.ServicePort}/values/test&quot;); var result = await response.Content.ReadAsStringAsync(); return result; } }}","link":"/2020/03/25/DotnetConsul/"},{"title":"Gnome3桌面环境添加应用文件夹","text":"前几天安装完 Wine 以后，发现 Gnome 桌面的应用窗口已经不能看了，各种被 WIne 的图标霸占，而且特别杂，显得非常凌乱，我就想能不能自己创建一个 Wine 文件夹，然后把他们全放进去，但是 Gnome 好像不支持拖拽重叠生成文件夹，通过 WIKI，发现了 gsettings 命令方法： 以下是 Gnome For WIKI 原文： It should return and empty square brackets list. If not, you may wish to add the content of this list to your new list in the following commands instead of replacing it.To add the folders, proceed as follow:gsettings set org.gnome.desktop.app-folders folder-children “[‘AppFolderName’]”What if you want almost all applications in one or more categories except few of them? You can simply specify an exclusion list using the key excluded-apps. For example, suppose we want to exclude Acrobat Reader from the Office folder:gsettings set ‘org.gnome.desktop.app-folders.folder:/org/gnome/desktop/app-folders/folders/AppFolderName/‘ apps “[‘gnome-maps.desktop’]” 他是首先通过gsettings指令向org.gnome.desktop.app-folders这个 XML 标记文件读取一下结构，（有兴趣研究一下这个 XML 的同学请跳转到：**/usr/share/glib-2.0/schemas/org.gnome.desktop.app-folders.xml）**，然后再写入到 Gnome-dconf”类 WIndows 注册表中”，然后通过 gsettings ………apps 这个命令向文件夹中添加程序。 但是我发现这种方法好像并不是很灵活，像删除、重命名、文件夹图标等等都没有说明，于是还是我自己研究一下把。 我的方法是首先通过打开dconf-editor，搜索 WIKI 中所说的那个 xml 文件org.gnome.desktop.app-folders结果如下： 是不是很眼熟，Utilities 也就是 Gnome 默认的杂项文件夹，而 Sundry 就是工具文件夹，有了这个思路，是不是往Folder-children里面添加 项 就能创建文件了，答案是：不是，无论怎么添加。 在下面的 folder 节点中都不会出现你创建的 文件夹 项名，已经对应的项 名称 和 值。 再次 google-WIKI，发现了另一种方法： 1。通过 Gnome 自带的软件商店，点击已安装，然后点击右上角的勾号，选中一个软件后，点击左下角的添加到目录以后，点击 “+”号后，就能创建一个文件夹，而且会出现在 dconf 的 folder 节点下，根据其余两个自带文件夹的创建规则，我们需要打开 terminal。 2。然后转到 /usr/share/desktop-directories 这个目录下，创建一个 xxxx.directory 文件，然后写入如下： [Desktop Entry] &gt; Name=Zwin #主名称Name[zh_CN]=组件 1 #简体中文的名称Icon=applications-other #应用文件夹图标，可以是绝对路径的图标，applications-other #就会像自带的那样显示文 件夹中应用的缩略图。Type=Directory #类型 Directory 项文件 3.创建完成以后，我们打开 dconf-editor，跳转到 org/gnome/desktop/app-folders/folders然后打开用 gnome 应用商店中创建的那个项。参数解释如下： apps需要放入这个文件夹的应用名称，详细参考：/usr/share/applications 目录中所有应用的 desktop 文件名称，格式 [‘xxxxxx0.desktop’, ‘xxxxxxx1.desktop’,’xxxxxxx2.desktop’] categories这个类别名称，填写第二步中创建的 directory 文件的名称即可，不需要带后缀名 excluded-apps默认[]即可 name填写 directory 文件的全名，带后缀名。 translate转化，勾选。 这样就创建完成了，以后需要添加或者删减文件夹中的应用，用 dconf 修改 apps 项即可，如果需要改变应用文件夹的图标，名称，修改 /usr/share/desktop-directories/directory文件即可，不想要这个应用文件夹了，在 dconf 中删除 apps 项中的所有，然后删除 directory 文件即可。","link":"/2017/03/23/GnomeDesktopAddApplicationFolder/"},{"title":"你好，Blazor","text":"随着 .NET 5.0 预览版的出现，Blazor 也正式发布了，之前写过一个英雄联盟的战绩查询网站，用的是初代的 Blazor ，现在 dotnet 5.0 preview 也正式更新了全新的 Blazor，我也是第一时间体验，毕竟大家都是有经验的程序员，我们只从技术选型，开发体验，框架设计等维度，浅层的聊一聊， Web 开发与 JavaScript 开发向来是同义词。直到 WebAssembly 的横空出世，WebAssembly (Wasm)是一种在浏览器中可以执行的二进制指令。 WebAssembly 的 官方工具链 能够编译 C/C++ 代码，但许多社区也提供了不同语言的编译器，如 Rust，Python，Java 和 Blazor(C#)。特别是 Rust 社区非常活跃，可以开始看到完整的前端框架，如 Yew 和 Dodrio，这为基于浏览器的应用带来了更多新的可能性，只要测试一些使用 WebAssembly 构建的优秀应用，就可知道基于浏览器的近乎原生的应用现在已经成为现实，例如 Sketchup 或 Magnum。WebAssembly 被设计为可以和 JavaScript 一起协同工作——通过使用 WebAssembly 的 JavaScript API，你可以把 WebAssembly 模块加载到一个 JavaScript 应用中并且在两者之间共享功能。这允许你在同一个应用中利用 WebAssembly 的性能和威力以及 JavaScript 的表达力和灵活性。 接下来我们就来看一下如何快速构建一个 Blazor 应用。 1. 安装 Dotnet Core 3.0Windows / Linux / Mac OS 同学可以在这里手动下载安装： https://dotnet.microsoft.com/download Windows Chocolatey 用户可以这样： 1choco install dotnetcore Linux Apt-Get 用户可以这样： 1sudo apt-get install dotnet-sdk-3.1 Mac OS Homebrew 用户可以这样 1brew cask install dotnet-sdk 安装结束以后可以看一下支持的快速构建模版，命令： 1dotnet new -l 这里就是所有支持的模版，好了，开发环境就已经准备好了。 2. 创建 Blazor 项目我们直接使用 dotnet 的模板命令： 1dotnet new blazorserver -o HelloBlazor 通过几秒钟的等待，一个 Blazor Server App 就创建出来了，我们使用 VS Code 打开项目，来解读一下项目文件 123456789101112131415161718192021222324252627282930313233343536373839404142├── App.razor #负责 Assembly 组建的注入├── Startup.cs #启动器，负责IOC注入，配置注入等├── Program.cs #程序主入口├── _Imports.razor #导入项声明├── appsettings.Development.json #开发环境配置文件├── appsettings.json #生产环境配置文件├── HelloBlazor.csproj #项目文件├── Data│ ├── WeatherForecast.cs #天气业务模型│ └── WeatherForecastService.cs #天气服务├── Pages│ ├── Counter.razor #计数器视图│ ├── Error.razor #错误视图│ ├── FetchData.razor #加载数据视图│ ├── Index.razor #Home视图│ └── _Host.cshtml #主视图，布局页├── Properties│ └── launchSettings.json #启动配置├── Shared│ ├── MainLayout.razor #页面主布局│ ├── NavMenu.razor #导航菜单│ └── SurveyPrompt.razor #提示页└── wwwroot #站点资源，样式表，JS，字体，图标 ├── css │ ├── bootstrap │ │ ├── bootstrap.min.css │ │ └── bootstrap.min.css.map │ ├── open-iconic │ │ ├── FONT-LICENSE │ │ ├── ICON-LICENSE │ │ ├── README.md │ │ └── font │ │ ├── css │ │ │ └── open-iconic-bootstrap.min.css │ │ └── fonts │ │ ├── open-iconic.eot │ │ ├── open-iconic.otf │ │ ├── open-iconic.svg │ │ ├── open-iconic.ttf │ │ └── open-iconic.woff │ └── site.css └── favicon.ico 3. 深入解读 Blazor路由我们看到 Pages 页面下都会有 @page “/“ @page “/counter” @page “/error” @page “/fetchdata” 其实这些就是页面的路由，如果我们输入一个不存在的页面地址会发生什么呢？ 这就是 App.razor 里头 NotFound 节点的作用了。 页面会直接显示规定的内容 12345&lt;NotFound&gt; &lt;LayoutView Layout=&quot;@typeof(MainLayout)&quot;&gt; &lt;p&gt;Sorry, there's nothing at this address.&lt;/p&gt; &lt;/LayoutView&gt;&lt;/NotFound&gt; 运行模式首先 Blazor 可以以两种模式运行（他们有着很本质的区别）： Server-Side Client-Side Server-Side 也被称为 Blazor 服务器，它是完全运行于服务器上面，也就是说客户端的浏览器只是一个空壳页面，它不包含任何的逻辑和除了首页（通常会被称为‘_Host’）以外的任何页面，该种模式完全托管于服务器，UI 的修改已经前端所发生的一切事件都需要传往服务器进行计算。传输的过程使用的是 SignalR 的方式。 使用这种方式意味着对于服务器的带宽以及性能要求会极其之高，但是对于一些需要使用到 SignalR 的应用以及一些访问量不大的地方使用 SignalR 也许会有不小的用途，因为事件模式的驱动方式，会让我们的应用有很高的灵活性和无限可能，并且在无操作的情况下，网页仍需要定期发送心跳包确认服务器状态，若服务器无响应，则整个网页停止服务。 我们尝试关掉后台服务进程。 我们会发现页面提示我们连接异常 重新打开后台服务后，刷新页面，页面恢复正常工作 这表示 Server-Side 模式是长链接模式，应用场景可以为 IM 通讯，大数据展示等。 Client-Side 是 SPA(Single Page Application)应用，基于一种叫 WebAssembly 的技术，WebAssembly(wasm)是一个开发的 web 标准，它是一种很底层的类似于字节码的东西，WebAssembly 可以通过 JavaScript 访问浏览器的完整功能。在我们.NET 运行在浏览器之前，Blazor 会提前向浏览器发送一个可以运行在 WebAssembly 上的迷你版本的 mono，我们知道.NET 中的语言是可以运行在 mono 之上的，因此我们就等于变相的实现了在浏览器中运行.NET。并且所有代码都是在 JavaScript 沙盒中运行，也防御了许多不安全操作。 对于客户端模式，Blazor 是将整个项目程序集和运行时(mono)一同发送到了浏览器，通过 WebAssembly 对 JavaScript 互操作处理 DOM 节点和相关 api 的调用。 两种方式对比 事实上两种方式都有其优缺点，ServerSide 在访问量并不是那么大的时候，或者说你的服务器足够好的时候，可以很轻松的完成需要的任务，并且在网络聊天这种需要保持长期的网络连接的时候，ServerSide 显然是首选，对于一些博客、或者一些普通的以页面展示为目的的网站，ClientSide 显然要比 ServerSide 好一些，但是 ClientSide 有一个致命的缺点，也就是你的代码质量必须高，代码需要精简。因为你的程序集的大小会影响你的加载速度，因此我们应当尽可能缩小程序集。 中间件在微软提供的模板上面，大体上还是和我们的 ASP.NET Core 是接近的。在依赖注入中，因为我们利用了 Razor 来实现 C#和 html 的混合编码以及我们使用的是 ServerSide 的 Blazor，注入代码如下： 123456public void ConfigureServices(IServiceCollection services){ services.AddRazorPages(); services.AddServerSideBlazor(); services.AddSingleton&lt;WeatherForecastService&gt;();} 第一行添加了 Blazor 页面的支持 第二行制定运行模式为 Server-Side 第三行注入了单例的 Weather Service 我们再看到 UseEndpoints 做了一些什么事情，首先看到代码： 12345app.UseEndpoints(endpoints =&gt;{ endpoints.MapBlazorHub(); endpoints.MapFallbackToPage(&quot;/_Host&quot;);}); 第一行，匹配我们的 signalR 的连接 第二行，会自动到 Pages 下面去找我们的页面文件 这一篇文章下来，大家对 Blazor 有了大致的了解，接下来的文章我打算讲解一下如何进行 Blazor 的实战开发。","link":"/2020/05/01/HelloBlazor/"},{"title":"Hexo加速渲染速度之Fragment Cache","text":"从使用 Hexo 到现在已经陆续写了几十篇文章了，现在发现了严重的问题，hexo generate 渲染的速度越来越慢，现在 35 篇左右，每次渲染时间到达了 20+ s，查看了官方 api，看到了 fragment_cache 局部缓存这个东西，解决了渲染速度的问题。 使用官方文档局部缓存。它储存局部内容，下次使用时就能直接使用缓存。 1&lt;%- fragment_cache(id, fn); %&gt; 替换简单文本区域 1.我们可以将所有页面都一样的区域，如下所示，缓存下来。当下一篇文章在渲染到这个位置时，将不再渲染，直接拿缓存数据。 123&lt;%- fragment_cache('header', function(){ return partial('&lt;head&gt;&lt;/head&gt;');}) %&gt; 2.文章模块也可以使用，原来公共引用部分（没有和当前文章耦合的内容）使用下面的方式： 1&lt;%- partial('_partial/header'); %&gt; 改进为以下代码 123&lt;%- fragment_cache('header', function(){ return partial('_partial/header');}) %&gt; 使用这个语法以后，现在的渲染速度已经提升了一倍","link":"/2019/02/20/Hexo_ragment_cache/"},{"title":"Kubuntu 配置 Shadownsocks","text":"最近买了一台 HUAWEI Matebook X Pro 用于跨平台开发（其实就是看到这么窄的边框无法自拔）,装上 Kubuntu 以后整个人更起飞了，因为彻底得无法打英雄联盟了，那只能上 YouTube 看看视频吧，发现 Linux 下 Shadownsocks 使用还是没有 Windows 版本那么方便 第一步安装 shadowsocks1sudo apt-get install shadowsocks 第二步配置 shadowsocks安装完成之后默认的配置文件在**/etc/shadowsocks/local.json**，去将里面的配置修改成自己的即可。 123456789101112{ &quot;server&quot;:&quot;xxx.xxx.xxx.xxx&quot;, &quot;server_port&quot;:xxx, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;xxx&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;aes-256-cfb&quot;, &quot;fast_open&quot;: true, &quot;workers&quot;: 1, &quot;prefer_ipv6&quot;: false} 第三步启动 shadowsocks1sudo sslocal -c /etc/shadowsocks/local.json -d start 第四步配置 pac 规则1. 安装 GenPac12sudo pip install genpacpip install --upgrade genpac 2. 新建 pac 配置存放目录用来存放用户自定义规则列表文件 user-rules.txt 和生成后的 autoproxy.pac 文件，例如我的放在 home 目录下 123mkdir ~/soft/paccd ~./soft/pactouch user-rules.txt 3. 生成 autoproxy.pac 文件我使用的是 github 上托管的这份文件：https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt执行一下命令来创建 autoprox.pac 1genpac --pac-proxy &quot;SOCKS5 127.0.0.1:1080&quot; --output=&quot;autoproxy.pac&quot; --gfwlist-url=&quot;https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt&quot; --user-rule-from=&quot;user-rules.txt&quot; 4. 配置系统代理去 Ubuntu设置 -&gt; 网络 -&gt; 代理设置设置代理，选择自动，配置 url 填写你本地的文件路径，例如：file:///home/xxx/soft/pac/autoproxy.pac","link":"/2019/01/31/Linux-shadownsocks/"},{"title":"Linux的GRUB2启动文件修改","text":"对于装了 KALI 和 Fedora 等 Linux 的同学来说，通过默认的启动器 GRUB2 总是有一些不尽人意的地方，比如 timeout 过长或者过短，启动界面难看。甚至有多于的内核启动项。 首先大家需要了解四个位置： /boot/grub2/grub.cfggrub.cfg 的启动配置文件，属于 LEGACY 引导模式 /boot/efi/EFI/fedora/grub.cfggrub.cfg 的启动配置文件，属于 UEFI 引导模式 /etc/default/grubgrub 的默认配置文件，可以修改一些常见的参数 /etc/grub.d这个文件夹下面是一些生成 grub.cfg 文件的可执行脚本，可以修改 现在开始的话就是开始了解怎么通过设置，修改出自己满意的 GRUB 启动器来。 grub2 的原理是这样：首先通过修改自定义参数，也就是/etc/default/grub 和/etc/grub.d/文件，然后通过终端的 grub2-mkconfig grub.cfg 文件目录 这个命令读取/etc/default/grub 和/etc/grub.d/文件生成新的 grub.cfg 启动文件。 下面开始说一下/etc/default/grub 这个文件的参数： GRUB_DEFAULT=0设置默认启动项，按 menuentry 顺序如果要默认从第四个菜单项启动，数字改为 3，若改为 saved，则默认为上次启动项 GRUB_HIDDEN_TIMEOUT=0前面有#注释将会显示引导菜单，没有#注释将会不显示引导菜单 GRUB_HIDDEN_TIMEOUT_QUIET=true黑屏，并且不显示 GRUB_HIDDEN_TIMEOUT 过程中的倒计时 GRUB_TIMEOUT=”10”设置进入默认启动项的等候时间，默认值 10 秒，按自己需要修改，单位为秒改改为零和负值为无限等待操作 GRUB_DISTRIBUTOR=`lsb_release -i -s 2&gt; /dev/null || echo Debian`获得发行版名称（比如 Ubuntu, Debian） GRUB_CMDLINE_LINUX_DEFAULT=”quiet splash”选择启动的环境，“quiet splash”为图像界面，“text”为文本界面 GRUB_CMDLINE_LINUX=”noresume”手动添加内核启动参数，比如 acpi=off noapic 等可在这里添加。） GRUB_TERMINAL=console设置是否使用图形介面。#注释掉以后（使用图形界面），前面没有#注释（仅使用控制台终端，不使用图形介面) ) GRUB_GFXMODE=640x480设定图形介面分辨率，如不使用默认。把前面#去掉，把分辨率改为 800x600 或 1024x768 GRUB_DISABLE_LINUX_RECOVERY=”true”设定是否创建修复模式菜单项，前面有#注释（建立修复模式）.前面没有#注释（不建立修复模式） GRUB_INIT_TUNE=”480 440 1”当 GRUB 菜单出现时发出鸣音提醒，户无法看到屏幕特别有用,默认关闭，在此处不能设置开启 GRUB_THEME=”主题文件 theme.txt 绝对地址” 这个参数用于设置，图形化界面下的启动界面主题。说完了参数，现在开始要说一下实战教程了，大家可以通过上述的参数任意修改。 现在说一下主题文件的加载吧。首先需要下载主题，放到一个自己能知道的位置。 然后打开终端，vim /etc/default/grub 可以看到，现在我们设置来倒计时为 5 秒，启动分辨率为 1920x1080，默认启动上次的系统，然后加载了**/boot/grub2/themes/Aurora-Penguinis-GRUB2/theme.txt**这个位置的一个主题文件，并且启用来图形化引导界面。 这里要说一下，如果要启用图形化的引导界面，我需要删掉或者注释掉：GRUB_TERMINAL=console这条参数。 然后我们用grub2-mkconfig -o这条命令生成新的启动文件。 注意事项1.假如你加载了主题文件，执行命令以后需要看到 Found theme 这条提示，这才表示我们的主题文件成功启用了。 2.如果你是用 LEGACY 引导模式的话，请执行：grub2-mkconfig -o /boot/grub2/grub.cfg 这条生成命令。 如果你是用 UEFI 引导模式的话，请执行：grub2-mkconfig -o /boot/grub2/grub.cfg 这条命令。 没有出现错误提示以后，重启就能看到效果了： 现在开始讲引导菜单栏的名称修改，以及双系统的引导修复。比如你是Fedora+Windows 10 首先引导菜单栏名称修改： menuentry 标签后的‘xxxxx’ 就是引导菜单栏的名称，而且他们是有层次关系 menuentry1标签在menuentry2上面，那么启动 GRUB2 图形化/终端的时候menuentry1标签中的选项就会在menuentry2上面。所以想修改启动项的排序关系，也可以通过修改menuentry标签,双系统的引导修复，在于修改 /boot 下的 grub.cfg文件。 注意 LEGACY 和 UEFI 是不共用一个 cfg 文件的。这点在文章的前面就已经指明了，修改对应的文件很关键。 照例VIM /boot/efi/EFI/fedora/grub.cfg （我是 Fedora Linux，并且 UEFI 引导） 然后在第一个menuentry标签的上或者下 ，添加 1234menuentry 'win10_pro_x64' {set root=(hd0,1)chainloader+1} 这里假设的是 Win10 作业系统。 这里需要注意的是 set root 这条参数，menuentry 这条参数没有什么好讲的，就是一个选项名称。 set root（hd0，1） hd0： 硬盘名称，一般 linux 下都是以 sda sdb sdc 命名 1 ： 作业系统所在分区区号 如果不知道系统所在的分区，请终端执行： fdisk -l (sudo 或者 root 运行)","link":"/2017/04/02/LinuxGrubConfigEdit/"},{"title":"Prism Step1 BootstrapperShell","text":"BootstrapperShell 是 Prism 很重要的理念之一，调用 Bootstrapper 类进行程序主窗体的引导和构造，每一个基于 Prism 架构的应用，都将通过这个基类开始。 官方的第一章 教程，向我们展示了 BootstrapperShell 的初级使用方法 App.xaml.cs{.line-numbers}12345678910public partial class App : Application { protected override void OnStartup(StartupEventArgs e) { base.OnStartup(e); var bootstrapper = new Bootstrapper(); bootstrapper.Run(); } } 重写 OnStartUp 方法，调用 Bootstrapper 类进行初始化，Bootstrapper 的意义在于创建 主窗体，以及加载开始启动所需的默认模块等。 BootstrapperShell.cs{.line-numbers}123456789101112class Bootstrapper : UnityBootstrapper { protected override DependencyObject CreateShell() { return Container.TryResolve&lt;MainWindow&gt;(); } protected override void InitializeShell() { Application.Current.MainWindow.Show(); } } Bootstrapper 类很简洁，就包含了 CreateShell 和 InitializeShell 方法 CreateShellPrism 使用依赖注入模式来管理组件之间的依赖，Prism 被设计使用 Unity、MEF 等 IOC (依赖注入)注册容器，此方法就是通过 Unity容器注册主窗口的窗体对象。 InitializeShell显示应用程序的主窗体，对于 Prism 架构而言，这里很好理解，是通过 CreateShell 注册的主窗体对象，常规开发，主窗体对象是在 App.xaml 的 {.line-numbers}12345678&lt;Application x:Class=&quot;WPF_AForge_Screen_Capurte_Demo.App&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;clr-namespace:WPF_AForge_Screen_Capurte_Demo&quot; StartupUri=&quot;MainWindow.xaml&quot;&gt; &lt;Application.Resources /&gt;&lt;/Application&gt; StartupUri 这里设置 那么第一章就结束了了，大家已经对 Prism 如何引导 主窗体 注册和显示有了一定的概念了，也意识到了与常规模式的不同，Bootstrapper 中还有很多高级应用，如 VM 定位器，模块导入配置等。","link":"/2017/05/21/Prism-01-BootstrapperShell/"},{"title":"Prism Step2 Regions","text":"Prism 可以帮助我们开发模块化程序，将程序分割成一个个独立的 Module，分别进行开发。然后在程序运行的时候，将各个 Module 组合到一起，为程序提供各种各样的功能。通常来说，Module 是一些视图和功能的集合，那么就需要一种办法来将这些视图以某种形式，在特定的时间展现出来。Prism 通过 Shell + Region 来组织视图的布局，完成视图间的转换等。 Shell 相当于 ASP.NET 中的母版页，它定义了页面的布局、主题等。其中的导航区和内容区是预留出来的需要进行填充内容的部分，也就是 Region，起到占位符的作用，程序会在运行时动态地向 Region 中填充内容。 那么如何将一个区域定义为 Region 呢？ 首先在引入 Prism 的命名空间 xmlns:prism=”http://www.codeplex.com/prism&quot; 如果 IDE 无法找到这个命名空间的话，需要先注册 Prism，然后在需要定义为 Region 的控件上加上 Attached Property。 1&lt;ContentControl prism:RegionManager.RegionName=&quot;MainRegion&quot; /&gt; 并不是所有的控件都可以作为 Region 的，需要为需要定义为 Region 的控件添加 RegionAdapter。RegionAdapter 的作用是为特定的控件创建相应的 Region，并将控件与 Region 进行绑定，然后为 Region 添加一些行为。一个 RegionAdapter 需要实现 IRegionAdapter 接口，如果你需要自定义一个 RegionAdapter，可以通过继承 RegionAdapterBase 类来省去一些工作。Prism 为 Silverlight 提供了几个 RegionAdapter： ContentControlRegionAdapter创建一个 SingleActiveRegion 并将其与 ContentControl 绑定 ItemsControlRegionAdapter创建一个 AllActiveRegion 并将其与 ItemsControl 绑定 SelectorRegionAdapter创建一个 Region 并将其与 Selector 绑定 TabControlRegionAdapter创建一个 Region 并将其与 TabControl 绑定 通常我们并不直接和 Region 打交道，而是通过 RegionManager，它实现了 IRegionManager 接口。IRegionManager 接口包含一个只读属性 Regions，是 Region 的集合，还有一个 CreateRegionManager 方法。Prism 通过 RegionManagerExtensions 类使用扩展方法为 IRegionManager 添加了更多的功能。 AddToRegion将一个视图添加到一个 Region 中。 RegisterViewWithRegion将一个视图和一个 Region 进行关联。当 Region 显示的时候，关联的视图才会显示，也就是说，在这个 Region 显示之前，关联的视图是不会被创建的。 RequestNavigate进行页面切换，将指定的 Region 中显示的视图切换为指定的视图。 本文开头说过，需要在运行时将分散在各个 Module 的视图显示在页面特定的位置上。那么首先就需要定义页面显示的地方，即 Region。然后就是要定义创建视图的时机和方式。在 Prism 中有两种方式来定义视图与 Region 之间的映射关系——View Discovery 和 View Injection。 如果一个页面相对来说不大变化，如导航区，在程序初始化的过程完成后就不会轻易地变动，这时候就较适合于使用 RegisterViewWithRegion 方法，通常可以在 Module 的 Initialize 方法中完成这个过程 12345678public void Initialize(){ logger.Log(&quot;初始化Navigation模块&quot;, Category.Debug, Priority.Low); _regionManager.RegisterViewWithRegion(RegionNames.NavRegion, typeof(NavigationItem)); _regionManager.RegisterViewWithRegion(RegionNames.MainRegion, // 两种方式都可以 () =&gt; _container.Resolve&lt;NavigationContainer&gt;() ); _regionManager.RegisterViewWithRegion(RegionNames.NavDemoActionRegion, typeof(ActionController));} 如果一个区域需要频繁地切换页面的话，如主内容区，可以使用 View Injection 的方式。 1234IRegionManager regionManager = ...;IRegion mainRegion = regionManager.Regions[&quot;MainRegion&quot;];InboxView view = this.container.Resolve&lt;InboxView&gt;();mainRegion.Add(view); 可以看到，这时候已经生成了视图的实例。之前提到过，一个 Region 可以包含多个视图，这些视图会处于不同的状态，对于 ItemsControl 类型的 Region 来说，里面会显示很多个 Item，所以添加进去就可以了；但是对于 ContentControl 这种 Region，同一时刻只能显示一个视图，所以在添加进去之后还需要有一个 Activate 的过程。 使用 URI 来进行导航只需要提供需要切换的视图的名称就可以，并不需要了解视图的类型，从而达到解耦的目的，并且可以通过 URI 来进行参数传递。 123456public void Initialize(){ _container.RegisterType&lt;object, ViewA&gt;(ViewNames.ViewA); _container.RegisterType&lt;object, ViewB&gt;(ViewNames.ViewB); _container.RegisterType&lt;object, ViewC&gt;(ViewNames.ViewC);}","link":"/2019/02/17/Prism-02-region/"},{"title":"Prism Step3 CustomRegions","text":"Prism系列的第三篇，我的更新速度也是有点慢，大家凑活看吧，这一片主要讲自定义占位符的使用，Regions是定义在应用UI中的逻辑占位符(在Shell或者在其它的视图中)，视图会在其中显示。简单的说，就是一个容器（区域适配器），用来装载Views。功能和Panel控件差不多。视图可以以编程的方式或者自动被显示在Region中。 说明1 . Regions允许在不需要改变程序逻辑的情况下更新应用UI的布局。 2 . 很多普通的控件都当做regions来使用，允许视图自动在控件中显示，就像ContentControl，ItemsControl，ListBox或者TabControl 。 但是StackPanel就不能直接作为Regions来使用。 3 . Prism也支持用regions来实现导航。 4 . Regions可以通过RegionManager组件定位于其它组件中，RegionManager使用 RegionAdapter和RegionBehavior组件调整某个regions中显示的视图. 实例 Prism-Samples-Wpf 官方教程的第三篇就是讲上面如何把一个不能作为 Regions 的布局容器实现 Regions 功能，你需要为一个将被用作Region的添加RegionAdapter（适配器）。RegionAdapter的作用是为特定的控件创建相应的Region，并将控件与Region进行绑定，然后为Region添加一些行为。一个RegionAdapter需要实现IRegionAdapte接口，如果你需要自定义一个RegionAdapter，可以通过继承RegionAdapterBase类来省去一些工作。 我们看到官方的教程中有一个叫做 StackPanelRegionAdapter.cs 的类，这个类其实就是为StackPanel建立了Region 12345678910111213141516171819202122232425262728293031323334353637using Prism.Regions;using System.Windows;using System.Windows.Controls;namespace Regions.Prism{ public class StackPanelRegionAdapter : RegionAdapterBase&lt;StackPanel&gt; { public StackPanelRegionAdapter(IRegionBehaviorFactory regionBehaviorFactory) : base(regionBehaviorFactory) { } protected override void Adapt(IRegion region, StackPanel regionTarget) { region.Views.CollectionChanged += (s, e) =&gt; { if (e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Add) { foreach (FrameworkElement element in e.NewItems) { regionTarget.Children.Add(element); } } //handle remove }; } protected override IRegion CreateRegion() { return new AllActiveRegion(); } }} 我们来看一下这个类，首先这个类继承自 RegionAdapterBase 顶级泛型区域适配器类，并且指明类型为 StackPanel，接下来有一个 适配器 Adapt 方法，这个方法就是用于当区域有新内容的时候，进行一个适配工作（其实就是添加元素到容器中） 我们来看 Bootstrapper 123456789101112131415161718192021222324252627282930using Microsoft.Practices.Unity;using Prism.Regions;using Prism.Unity;using Regions.Prism;using Regions.Views;using System.Windows;using System.Windows.Controls;namespace Regions{ class Bootstrapper : UnityBootstrapper { protected override DependencyObject CreateShell() { return Container.Resolve&lt;MainWindow&gt;(); } protected override void InitializeShell() { Application.Current.MainWindow.Show(); } protected override RegionAdapterMappings ConfigureRegionAdapterMappings() { RegionAdapterMappings mappings = base.ConfigureRegionAdapterMappings(); mappings.RegisterMapping(typeof(StackPanel), Container.Resolve&lt;StackPanelRegionAdapter&gt;()); return mappings; } }} 这里有一个重写方法，ConfigureRegionAdapterMappings 这个就是用于配置修改一些默认的区域适配器的，使不支持 Regions 支持，这样的话 StackPanel 控件就支持 Regions 了。 我们可以测试一下，在 MainWindow 中关联视图和区域 1234567891011121314151617181920212223using Prism.Regions;using System.Windows;namespace Regions.Views{ /// &lt;summary&gt; /// Interaction logic for MainWindow.xaml /// &lt;/summary&gt; public partial class MainWindow : Window { public MainWindow() { InitializeComponent(); RegionManager regionManager = new RegionManager(); for (int i = 0; i &lt; 10; i++) { regionManager.RegisterViewWithRegion(&quot;ContentRegion&quot;, typeof(ViewA)); } } }} 运行就可以看到，原本不支持 regions 的 stackpanel容器放下了 十个视图，Prism官方推出，RegionAdapter的目的应该是让开发者在视图布局上面更加灵活。","link":"/2019/02/19/Prism-03-customsregions/"},{"title":"Prism Step4 ViewModelLocationProvider","text":"ViewModel 是对应的 View（数据和行为）的抽象，View 只是 ViewModel 的一个消费者，那么还有其他的消费者吗？当然有了，那就是单元测试（Unit Test），这个后面说。ViewModel 为 View 提供数据上下文（DataContext），简单的说，你 View 需要展示的东西，都在我这里，你需要跟我绑定，包括数据和命令，Prism 提供了自动的 ViewModel 匹配。 约定的绑定方式1234567891011121314151617181920212223using Prism.Ioc;using Prism.Unity;using System.Windows;using ViewModelLocator.Views;namespace ViewModelLocator{ /// &lt;summary&gt; /// Interaction logic for App.xaml /// &lt;/summary&gt; public partial class App : PrismApplication { protected override Window CreateShell() { return Container.Resolve&lt;MainWindow&gt;(); } protected override void RegisterTypes(IContainerRegistry containerRegistry) { } }} ViewModel12345678910111213141516171819using Prism.Mvvm;namespace ViewModelLocator.ViewModels{ public class MainWindowViewModel : BindableBase { private string _title = &quot;Prism Unity Application&quot;; public string Title { get { return _title; } set { SetProperty(ref _title, value); } } public MainWindowViewModel() { } }} View 视图1234567891011&lt;Window x:Class=&quot;ViewModelLocator.Views.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:prism=&quot;http://prismlibrary.com/&quot; prism:ViewModelLocator.AutoWireViewModel=&quot;True&quot; Title=&quot;{Binding Title}&quot; Height=&quot;350&quot; Width=&quot;525&quot;&gt; &lt;Grid&gt; &lt;ContentControl prism:RegionManager.RegionName=&quot;ContentRegion&quot; /&gt; &lt;/Grid&gt;&lt;/Window&gt; 正常的绑定方式 1123&lt;UserControl.DataContext&gt; &lt;vm:NumberChangeLogViewModel /&gt;&lt;/UserControl.DataContext&gt; 方式 2123&lt;vw:NumberView DockPanel.Dock=&quot;Top&quot; DataContext=&quot;{Binding Path=Number, Mode=OneTime}&quot; /&gt; Prism 源码123456789101112131415161718/// &lt;summary&gt;/// ViewModelfactory that provides the View instance and ViewModel type as parameters./// &lt;/summary&gt;static Func&lt;object, Type, object&gt; _defaultViewModelFactoryWithViewParameter;/// &lt;summary&gt;/// Default view type to view model type resolver, assumes the view model is in same assembly as the view type, but in the &quot;ViewModels&quot; namespace./// &lt;/summary&gt;static Func&lt;Type, Type&gt; _defaultViewTypeToViewModelTypeResolver = viewType =&gt; { var viewName = viewType.FullName; viewName = viewName.Replace(&quot;.Views.&quot;, &quot;.ViewModels.&quot;); var viewAssemblyName = viewType.GetTypeInfo().Assembly.FullName; var suffix = viewName.EndsWith(&quot;View&quot;) ? &quot;Model&quot; : &quot;ViewModel&quot;; var viewModelName = String.Format(CultureInfo.InvariantCulture, &quot;{0}{1}, {2}&quot;, viewName, suffix, viewAssemblyName); return Type.GetType(viewModelName); }; 自定义约束约定就是要来被打破的，有人可能觉得后缀加一个 ViewModel 实在是不太完美，但是可以改变吗？ 当然可以。 prism 为我们提供了一个可重写的 ConfigureViewModelLocator 的方法来配置 ViewModel 的定位器，如果你想修改默认的约定为 View 的名字后面+VM，你可以在 app.xaml.cs 这样写： 123456789101112protected override void ConfigureViewModelLocator() { base.ConfigureViewModelLocator(); ViewModelLocationProvider.SetDefaultViewTypeToViewModelTypeResolver((viewType) =&gt; { var viewName = viewType.FullName; var viewAssemblyName = viewType.GetTypeInfo().Assembly.FullName; var viewModelName = $&quot;{viewName}VM, {viewAssemblyName}&quot;; return Type.GetType(viewModelName); }); } 如果你想指定你绑定的 ViewModel 对象又不想遵循一定的规则，你同样可以在 ConfigureViewModelLocator 方法中注册绑定，像下面这样： 12345678910111213141516protected override void ConfigureViewModelLocator() { base.ConfigureViewModelLocator(); // type / type ViewModelLocationProvider.Register(typeof(MainWindow).ToString(), typeof(CustomViewModel)); // type / factory ViewModelLocationProvider.Register(typeof(MainWindow).ToString(), () =&gt; Container.Resolve&lt;CustomViewModel&gt;()); // generic factory ViewModelLocationProvider.Register&lt;MainWindow&gt;(() =&gt; Container.Resolve&lt;CustomViewModel&gt;()); // generic type ViewModelLocationProvider.Register&lt;MainWindow, CustomViewModel&gt;(); }","link":"/2019/02/23/Prism-04-ViewModelLocationProvider/"},{"title":"Prism Step5 PrismApplication","text":"7.1 Prism 更新以后，官方移除了 Bootstrapper 的方式引导启动 Prism 应用，取而代之的是 PrismApplication。 首先是 app.xaml 中的改动： 123456789&lt;prism:PrismApplication x:Class=&quot;Regions.App&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:prism=&quot;http://prismlibrary.com/&quot; xmlns:local=&quot;clr-namespace:Regions&quot;&gt; &lt;Application.Resources&gt; &lt;/Application.Resources&gt;&lt;/prism:PrismApplication&gt; 在6.x中，这里还是一个Application，现在已经改成prism:PrismApplication,然后是，App.xaml.cs 1234567891011121314151617181920using Prism.Ioc;using Prism.Unity;using Regions.Views;using System.Windows;namespace Regions{ public partial class App : PrismApplication { protected override Window CreateShell() { return Container.Resolve&lt;MainWindow&gt;(); } protected override void RegisterTypes(IContainerRegistry containerRegistry) { } }} 这里用了 Prism.Ioc和Prism.Unity,新的Prism.IoC命名空间，它创建了一个依赖注入容器的抽象。您现在只使用Prism提供的IContainerRegistry和IContainerProvider接口，而不是直接使用容器类。该IContainerProvider 接口用于从容器解析服务，IContainerRegistry 用于与容器登记类型。而之前的Unity也不再使用了，现在使用Prism.Unity，上面App.xaml.cs代码中 的PrismApplication 正是存在于Prism.Unity，如果你需要从6.x升级到7.x，所有的unity引用都需要删掉，重新添加Prism.Unity，并且修改相关代码。 Regions是应用程序UI的逻辑区域，它很像一个PlaceHolder，Views在Regions中展现，很多种控件可以被用作Region ：ContentControl、ItemsControl、ListBox、TabControl。 简单的说，就是一个容器（区域适配器），用来装载Views的。这像WinForms中的Container控件Panel，里面可以放置其他控件。在PRISM中，Views也是用户控件（UserControl） Region的注册方式： 说一句题外话，XAML是什么： XAML（Extensible Application Markup Language）是Windows Presentation Foundation（WPF）的一部分，是微软开发的一种基于XML、基于声明，用于初始化结构化值和对象的用户界面描述语言，它有着HTML的外观，又揉合了XML语法的本质，例如：可以使用标签设置按钮Button。 指定了Region，接下来就为Region指定View了。 在Views目录下面，新建一个UserControl，并在Grid控件内，加一个TextBlock，写上字，标识这是View A。 123456789101112131415161718using Prism.Regions;using System.Windows;namespace ViewDiscovery.Views{ /// &lt;summary&gt; /// Interaction logic for MainWindow.xaml /// &lt;/summary&gt; public partial class MainWindow : Window { public MainWindow(IRegionManager regionManager) { InitializeComponent(); //view discovery regionManager.RegisterViewWithRegion(&quot;ContentRegion&quot;, typeof(ViewA)); } }} [7.1updated]虽然7.1不再使用Unity，但这不影响我们来了解依赖注入容器在prism中的作用prism是使用依赖注入容器实现依赖注入的，这里我们使用的是Unity，Prism同样支持Mef容器实现依赖注入。[7.1updated]现已不再支持Mef容器了 如果使用 Unity 实例化一个类，该类的构造函数依赖一个或多个其他类，则 Unity 会为构造函数自动创建参数中指定的被依赖的类的实例。上面MainWindow的构造函数中的regionManager参数，就是Unity自动创建的。 RegionManager代码中RegionManager的RegisterViewWithRegion方法将我们的视图（View）和区域适配器（Region）进行关联 RegionManager，它实现了IRegionManager接口。IRegionManager接口包含一个只读属性Regions，是Region的集合（这个集合是从xaml中获取的，也就是我们定义的那些），RegionManager的实例会使用他们，并将view注册给他们。 View Discovery和View Injection在Prism中有两种方式来定义视图与Region之间的映射关系——View Discovery和View Injection。 上面的regionManager.RegisterViewWithRegion(“ContentRegion”, typeof(ViewA));就是View Discovery。 然后我们看一下View Injection： 1234567891011121314151617181920212223242526272829using Prism.Ioc;using Prism.Regions;using System.Windows;namespace ViewInjection.Views{ /// &lt;summary&gt; /// Interaction logic for MainWindow.xaml /// &lt;/summary&gt; public partial class MainWindow : Window { IContainerExtension _container; IRegionManager _regionManager; public MainWindow(IContainerExtension container, IRegionManager regionManager) { InitializeComponent(); _container = container; _regionManager = regionManager; } private void Button_Click(object sender, RoutedEventArgs e) { var view = _container.Resolve&lt;ViewA&gt;(); IRegion region = _regionManager.Regions[&quot;ContentRegion&quot;]; region.Add(view); } }} 他从_regionManager中获取Region，然后使用IRegion.Add(View)的方式来向已有的Region中添加View。 视图的激活与取消激活 激活： _region.Activate(_viewA); 取消： _region.Deactivate(_viewA);","link":"/2020/01/03/Prism-05-PrismApplication/"},{"title":"Prism Step6 Modules","text":"Modules 是能够独立开发、测试、部署的功能单元，Modules 可以被设计成实现特定业务逻辑的模块（如 Profile Management），也可以被设计成实现通用基础设施或服务的模块（如 Logging、Exception Management）。 既然 Modules 能够独立开发、测试、部署，那么如何告诉 Shell（我们的宿主程序）去 Load 哪些 Module，以怎样的形式 Load 这些 Module 呢？Prism 为此提供了一个叫 ModuleCatalog 的东西。他用这个来管理 Module。所以在 App 启动之初，需要创建配置一个 ModuleCatalog。 7.1 Prism 中更新了两个方法： 1234567// Summary:// Notifies the module that it has be initialized.void OnInitialized(IContainerProvider containerProvider);//// Summary:// Used to register types with the container that will be used by your application.void RegisterTypes(IContainerRegistry containerRegistry); 先新增一个 WpfApp 项目，命名 ModuleA，删除 App.config 和 App.xaml，然后将 outputType 改为 Class Library。 在 Views 文件夹下面新建一个用户控件 ViewA 新增一个类 ModuleAModule.cs 实现 IModule 接口（每一个 Module 类都要实现这个接口，而每一个 Module 都要有这样一个类来对 Module 里的资源统一管理） 123456789101112131415161718192021using ModuleA.Views;using Prism.Ioc;using Prism.Modularity;using Prism.Regions;namespace ModuleA{ public class ModuleAModule : IModule { public void OnInitialized(IContainerProvider containerProvider) { var regionManager = containerProvider.Resolve&lt;IRegionManager&gt;(); regionManager.RegisterViewWithRegion(&quot;ContentRegion&quot;, typeof(ViewA)); } public void RegisterTypes(IContainerRegistry containerRegistry) { } }} OnInitialized 实现的时候，顺便将一个 viewA 与 ContentRegion 进行关联，看代码 12var regionManager = containerProvider.Resolve&lt;IRegionManager&gt;();regionManager.RegisterViewWithRegion(&quot;ContentRegion&quot;, typeof(ViewA)); App.xaml.cs 中重写 ConfigureModuleCatalog 1234protected override void ConfigureModuleCatalog(IModuleCatalog moduleCatalog){ moduleCatalog.AddModule&lt;ModuleA.ModuleAModule&gt;();} App.xaml.cs 中重写 CreateModuleCatalog 1234protected override IModuleCatalog CreateModuleCatalog(){ return new ConfigurationModuleCatalog();} 这表示，ModuleCatalog 将从配置文件中创建。 App.config 中添加了节点，并且指定了需要 Load 的 module，并且设置了 startupLoaded 参数来告诉 shell，是否在启动时就加载他。下面是 App.config 的内容，他加载了一个名为 ModuleAModule 的 Module，存在 ModuleA.dll。 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;configuration&gt; &lt;configSections&gt; &lt;section name=&quot;modules&quot; type=&quot;Prism.Modularity.ModulesConfigurationSection, Prism.Wpf&quot; /&gt; &lt;/configSections&gt; &lt;startup&gt; &lt;/startup&gt; &lt;modules&gt; &lt;module assemblyFile=&quot;ModuleA.dll&quot; moduleType=&quot;ModuleA.ModuleAModule, ModuleA, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null&quot; moduleName=&quot;ModuleAModule&quot; startupLoaded=&quot;True&quot; /&gt; &lt;/modules&gt;&lt;/configuration&gt; DirectoryModulePath 就是你需要加载的 module 的 dll 生成目录 1234protected override IModuleCatalog CreateModuleCatalog(){ return new DirectoryModuleCatalog() { ModulePath = @&quot;.\\Modules&quot; };} LoadManual重写 ConfigureModuleCatalog 方法： 12345678910protected override void ConfigureModuleCatalog(IModuleCatalog moduleCatalog){ var moduleAType = typeof(ModuleAModule); moduleCatalog.AddModule(new ModuleInfo() { ModuleName = moduleAType.Name, ModuleType = moduleAType.AssemblyQualifiedName, InitializationMode = InitializationMode.OnDemand });}","link":"/2020/01/04/Prism-06-module/"},{"title":"Prism Step7 Command","text":"什么是Command？先看下微软官方的说明： Commanding is an input mechanism in Windows Presentation Foundation (WPF) which provides input handling at a more semantic level than device input. Examples of commands are the Copy, Cut, and Paste operations found on many applications. 命令是Windows Presentation Foundation（WPF）中的一种输入机制，它提供比设备输入更多的语义级别的输入处理。命令示例包括在许多应用程序中发现的“复制”，“剪切”和“粘贴”操作。 MainWindows.xaml 123456789101112131415&lt;Window x:Class=&quot;UsingDelegateCommands.Views.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:prism=&quot;http://prismlibrary.com/&quot; prism:ViewModelLocator.AutoWireViewModel=&quot;True&quot; Title=&quot;Using DelegateCommand&quot; Width=&quot;350&quot; Height=&quot;275&quot;&gt; &lt;StackPanel HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt; &lt;CheckBox IsChecked=&quot;{Binding IsEnabled}&quot; Content=&quot;Can Execute Command&quot; Margin=&quot;10&quot;/&gt; &lt;Button Command=&quot;{Binding ExecuteDelegateCommand}&quot; Content=&quot;DelegateCommand&quot; Margin=&quot;10&quot;/&gt; &lt;Button Command=&quot;{Binding DelegateCommandObservesProperty}&quot; Content=&quot;DelegateCommand ObservesProperty&quot; Margin=&quot;10&quot;/&gt; &lt;Button Command=&quot;{Binding DelegateCommandObservesCanExecute}&quot; Content=&quot;DelegateCommand ObservesCanExecute&quot; Margin=&quot;10&quot;/&gt; &lt;Button Command=&quot;{Binding ExecuteGenericDelegateCommand}&quot; CommandParameter=&quot;Passed Parameter&quot; Content=&quot;DelegateCommand Generic&quot; Margin=&quot;10&quot;/&gt; &lt;TextBlock Text=&quot;{Binding UpdateText}&quot; Margin=&quot;10&quot; FontSize=&quot;22&quot;/&gt; &lt;/StackPanel&gt;&lt;/Window&gt; MainWindowViewModel.cs 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465using System;using Prism.Commands;using Prism.Mvvm;namespace UsingDelegateCommands.ViewModels{ public class MainWindowViewModel : BindableBase { private bool _isEnabled; public bool IsEnabled { get { return _isEnabled; } set { SetProperty(ref _isEnabled, value); ExecuteDelegateCommand.RaiseCanExecuteChanged(); } } private string _updateText; public string UpdateText { get { return _updateText; } set { SetProperty(ref _updateText, value); } } public DelegateCommand ExecuteDelegateCommand { get; private set; } public DelegateCommand&lt;string&gt; ExecuteGenericDelegateCommand { get; private set; } public DelegateCommand DelegateCommandObservesProperty { get; private set; } public DelegateCommand DelegateCommandObservesCanExecute { get; private set; } public MainWindowViewModel() { ExecuteDelegateCommand = new DelegateCommand(Execute, CanExecute); DelegateCommandObservesProperty = new DelegateCommand(Execute, CanExecute) .ObservesProperty(() =&gt; IsEnabled); DelegateCommandObservesCanExecute = new DelegateCommand(Execute) .ObservesCanExecute(() =&gt; IsEnabled); ExecuteGenericDelegateCommand = new DelegateCommand&lt;string&gt;(ExecuteGeneric) .ObservesCanExecute(() =&gt; IsEnabled); } private void Execute() { UpdateText = $&quot;Updated: {DateTime.Now}&quot;; } private void ExecuteGeneric(string parameter) { UpdateText = parameter; } private bool CanExecute() { return IsEnabled; } }} View部分： 头部引入命名空间，指定ViewModeLocator模式： 12xmlns:prism=&quot;http://prismlibrary.com/&quot;prism:ViewModelLocator.AutoWireViewModel=&quot;True&quot; 接着是一个： 1&lt;StackPanel HorizontalAlignment=&quot;Center&quot; VerticalAlignment=&quot;Center&quot;&gt;&lt;/StackPanel&gt; 接着内部是一组控件，一个CheckBox四个Button一个 TextBlock。 1CheckBox IsChecked=&quot;{Binding IsEnabled}&quot; 复选框的勾选状态绑定到一个布尔型属性上。 1Button Command=&quot;{Binding ExecuteDelegateCommand}&quot; 普通命令绑定 1Button Command=&quot;{Binding ExecuteGenericDelegateCommand}&quot; CommandParameter=&quot;Passed Parameter&quot; 带参数的 命令绑定 1TextBlock Text=&quot;{Binding UpdateText}&quot; 为TextBlock的Text属性绑定数据源 Binding语法 Property=”{Binding PropertyPath}”，PropertyPath就是VM 当为Command进行Binding的时候，还可以带参数，使用CommandParameter属性，上面的CommandParameter指定了一个字符串“Passed Parameter”，当然还可以为其Binding一个对象。 ViewModel部分： set方法中的： SetProperty(ref _isEnabled, value);属性变更的通知，当视图状态更新后，会通知VM更改_isEnabled。 ExecuteDelegateCommand.RaiseCanExecuteChanged();这段代码，则会通知ExecuteDelegateCommand的可执行状态更改了，让他重新获取下可执行状态，那他是怎么获取可执行状态的呢？我们看下这个Command： ExecuteDelegateCommand = new DelegateCommand(Execute, CanExecute);new 的时候，有两个参数，第一个是Action（无返回类型的方法）Execute（需要执行的方法），第二个是一个Func，就是一个返回布尔型的方法CanExecute来获取command的可执行状态，当上面通知他可执行状态变更后，他就会重新调用CanExecute方法来获取目前的可执行状态（也就是按钮的可按下状态），来看下这个方法： 1234private bool CanExecute(){ return IsEnabled;} 很简单，直接返回了IsEnabled，而他是跟视图的CheckBox的IsChecked绑定的，当然也可以返回_isEnabled，而我更倾向后面这个，Public那个是给外人用的，蛤蛤。 当然可执行状态，还有其他的更优雅的写法，也就不用写ExecuteDelegateCommand.RaiseCanExecuteChanged();了，具体代码如下： 1234DelegateCommandObservesProperty = new DelegateCommand(Execute, CanExecute) .ObservesProperty(() =&gt; IsEnabled);DelegateCommandObservesCanExecute = new DelegateCommand(Execute) .ObservesCanExecute(() =&gt; IsEnabled); 下面这个是带参数的命令（command），他的回调函数需要一个string类型的参数，在new的时候要指定入参类型： 12ExecuteGenericDelegateCommand = new DelegateCommand&lt;string&gt;(ExecuteGeneric) .ObservesCanExecute(() =&gt; IsEnabled); 回调函数ExecuteGeneric： 1234private void ExecuteGeneric(string parameter){ UpdateText = parameter;}","link":"/2020/01/05/Prism-07-command/"},{"title":"程序单进程实例","text":"C#窗口实现单例模式的方法，对于一个软件如果第二次打开程序，就把已经启动的那个进程的窗口放到最前端显示 1 . 线程互斥量 - Mutex System.Threading.Mutex Mutex 是进程间同步的同步基元所以我们可以通过在主线程中构建互斥量来判断一个主进程是否启动多次 1234567891011protected override void OnStartup (StartupEventArgs e){ bool _isRuning = false; mutex = new Mutex (true, Assembly.GetExecutingAssembly().FullName, out _isRuning); if (!_isRuning) { MessageBox.Show (&quot;程序已经在运行,请勿重复启动！&quot;); Environment.Exit (0); } base.OnStartup (e);} 上面的代码是 WPF 项目，我们是重写App 级视图类的OnStartup方法，来达到启动的时候创建一个名为当前程序集名称的互斥量，如果 _isRuning 为 False 的时候，表示这个互斥量名称已经被别的主线程创建了，也就是已经有一个 实例 在运行了，因为主线程的互斥量属于系统级。 2 . 进程判断我们可以通过判断进程是否存在达到单实例模式的效果，但是缺点就是可以通过修改程序名或路径来达到重复启动的目的，不过一般用户情况下还是适用的。 Process current 1234567891011foreach (Process process in Process.GetProcessesByName (current.ProcessName)){ if (process.Id != current.Id) { if (process.MainModule.FileName == current.MainModule.FileName) { MessageBox.Show (&quot;程序已经在运行,请勿重复启动！&quot;); Environment.Exit (0); } }} 3 . 全局原子Win32 系统中，为了实现信息共享，系统维护了一张全局原子表，用于保存字符串与之对应的标志符的组合。我们需要引入 Kernel32.dll 1234567891011// 添加原子[System.Runtime.InteropServices.DllImport (&quot;kernel32.dll&quot;)]public static extern UInt32 GlobalAddAtom (String lpString);// 查找原子[System.Runtime.InteropServices.DllImport (&quot;kernel32.dll&quot;)]public static extern UInt32 GlobalFindAtom (String lpString);// 删除原子[System.Runtime.InteropServices.DllImport (&quot;kernel32.dll&quot;)]public static extern UInt32 GlobalDeleteAtom (UInt32 nAtom); 然后在主函数入口写上这样类似于这样的判断 12345678910if (GlobalFindAtom (Assembly.GetExecutingAssembly ().FullName) == 0){ GlobalAddAtom (Assembly.GetExecutingAssembly ().FullName); Run ();}else{ MessageBox.Show (&quot;程序已经在运行,请勿重复启动！&quot;); Environment.Exit (0);} 因为系统查找全局原子的时候，如果没有找到，会返回一个数值为 0 的UInt32类型值，所以通过这里就可以判断如果为0，那么我们添加这个原子然后启动应用程序 注意： 全局原子有一个需要注意的地方，就是在退出应用程序的时候需要删除这个原子，要不然系统会一直保留这个原子，导致你的程序无法正常启动 1GlobalDeleteAtom(GlobalFindAtom(Assembly.GetExecutingAssembly().FullName)); 活动已启动的程序窗口置顶 上面介绍了几种 .NET 程序的单实例实现方法，那么可能会有这样一个需求，就是当我们的应用程序已经启动，但是窗口状态处于最小化，或者隐藏在系统托盘的时候，我再次启动程序的时候，除了警告用户程序已启动，还需要把隐藏或者最小化的程序，最大化活动窗口置顶。 引入123456789101112131415161718192021222324private const int SW_HIDE = 0; //隐藏窗口，活动状态给令一个窗口private const int SW_SHOWNORMAL = 1; //用原来的大小和位置显示一个窗口，同时令其进入活动状态private const int SW_SHOWMINIMIZED = 2; //最小化窗口，并将其激活private const int SW_SHOWMAXIMIZED = 3; //最大化窗口，并将其激活private const int SW_SHOWNOACTIVATE = 4; //用最近的大小和位置显示一个窗口，同时不改变活动窗口private const int SW_RESTORE = 9; //用原来的大小和位置显示一个窗口，同时令其进入活动状态private const int SW_SHOWDEFAULT = 10; //根据默认 创建窗口时的样式 来显示// 恢复一个最小化的程序，并将其激活[System.Runtime.InteropServices.DllImport (&quot;User32.dll&quot;)]private static extern bool OpenIcon (IntPtr hWnd);// 窗口是否已最小化[System.Runtime.InteropServices.DllImport (&quot;User32.dll&quot;)]private static extern bool IsIconic (IntPtr hWnd);// 将窗口设为系统的前台窗口[System.Runtime.InteropServices.DllImport (&quot;User32.dll&quot;)]private static extern int SetForegroundWindow (IntPtr hWnd);// 异步ShowWindow[System.Runtime.InteropServices.DllImport (&quot;User32.dll&quot;)]private static extern bool ShowWindowAsync (IntPtr hWnd, int cmdShow); 实现方法1234567891011121314151617181920212223//获得当前实例的进程public static Process GetRunning (){ Process current = Process.GetCurrentProcess (); Process[] processes = Process.GetProcessesByName (current.ProcessName); foreach (Process process in processes) { if (process.Id != current.Id) { if (Assembly.GetExecutingAssembly ().Location.Replace (&quot;/&quot;, &quot;\\\\&quot;) == current.MainModule.FileName) { return process; } } } return null;}//调用Win32方法实现恢复活动窗口public static void HandleShowRunning (Process instance){ ShowWindowAsync (instance.MainWindowHandle, SW_SHOWNORMAL); SetForegroundWindow (instance.MainWindowHandle);} 调用1234567891011121314private static Mutex mutex = null;protected override void OnStartup (StartupEventArgs e){ Process instance = GetRunning (); bool _isRuning = false; mutex = new Mutex (true, Assembly.GetExecutingAssembly ().FullName, out _isRuning); if (!_isRuning) { HandleShowRunning (instance); MessageBox.Show (&quot;程序已经在运行,请勿重复启动！&quot;); Environment.Exit (0); } base.OnStartup (e);} 这里我们依然以WPF为例，调用了Win32的一些方法，实现在启动前，先检测是否已经有运行的实例，如果有获得该进程的Handle然后传给 Win32 方法实现激活窗口","link":"/2017/03/12/ProgramSingletonMode/"},{"title":"跨平台IM通讯软件","text":"此项目是我架构并且主导的桌面端聊天软件，完全由我负责桌面端的架构和管理，支持 Windows 和 MacOS 以及 Linux，使用 QT Framework 打造，具备常规聊天软件的所有功能，而且拥有丰富的动画效果和 Material Design 设计风格。 架构图如下（由于是公司项目，具体细节不能透露）：","link":"/2020/12/02/Project-IM/"},{"title":"多端餐厅管理系统","text":"此项目是我参与的核心项目之一，DinePlan 是一款餐厅管理系统，拥有管理整个餐厅的功能，销售报表，订单传递到厨房，使用令牌完美地管理交付和外卖订单，跟踪员工在工作上的时间；还跟踪班次和移交，通过短信和电子邮件向主要的利益相关者发送实时销售通知，信用卡，借记卡，钱包和现金付款方式，库存，门店柜台点餐管理等，覆盖整个餐饮流程。 主要使用的技术栈是 .NET, WPF, Azure, Avalonia, GRpc, .NET Core Asp, RabbitMQ, Sonar, JenKins, SQL Server 等。。。 （截图已经公司允许）","link":"/2020/12/04/ProjectDinePlan/"},{"title":"门店触屏点餐系统","text":"此项目是有我完全架构并主导编写的触屏点餐系统，拥有服务端和客户端，客户端安装在餐厅的触屏显示器上，类似肯德基，麦当劳的门店触屏点餐系统，此项目已经在新加坡上线（视频演示），服务于多家餐厅。 主要涉及技术： 描述 技术 平台 .NET Core 用户界面 Avalonia 后端逻辑 C# 通讯 GRpc 服务平台 Azure Queue RabbitMQ Cache Redis LocalDB SQL Server （截图已经公司允许）","link":"/2020/12/03/ProjectDinego/"},{"title":"智慧农田安卓监控APP","text":"个人项目（2018.03 - 2019.02） 外包项目，主要功能是连接农场的空气温度，空气湿度，土壤温度，土壤湿度，光照，二氧化碳浓度等传感器，通过蓝牙协议连接，进行数据化可视化的安卓平台，帮助农场主更好的进行灌溉，具体细聊，客户要对外保密。","link":"/2019/02/02/ProjectFlutterAmphet/"},{"title":"高达桌面交互套件","text":"个人项目（2013.07 - 2013.09） Rainmeter Gundam 是我高考前夕开发的，目的是还原高达 00 动漫中的 UI 界面，并且增加交互和可视化。主要涉及以下技术： 描述 技术 平台 Rainmeter UI 设计 Photoshop , AI 后台逻辑 Inc , Lua 脚本 完全由我一个人独立设计和开发，主要使用 Photoshop 设计 UI，Lua+Rainmeter 实现程序逻辑部分，现在在各大国内外美化论坛，还有 Rainmeter 聚集地下载超过 10W 次，并且获得 Rainmeter 国内官方论坛当时置顶一个月的待遇。 百度贴吧 , Rainmeter 论坛 , Github 开源 , 优酷演示 更多个人项目请查看我的Github","link":"/2013/09/25/ProjectGundam00/"},{"title":"英雄联盟战绩查询网站","text":"个人项目（2018.03 - 2018.04） KillTeemo 是为了方便查询英雄联盟游戏战绩所创建的个人站点，英雄联盟国服是没有开放数据 API 接口的，但是当时的 TGP 助手可以通过破解拦截请求获取 Token，然后通过 Token 向官网接口获取数据（过程有些复杂不便细说），整个站点的域名，服务器，站点都是我一个人设计开发，但是之后经营了一段时间以后，TGP 官方加强了 API 接口的安全性，使之无法获取 qquin (英雄联盟中玩家的唯一标识)，因为所有的战绩还有数据都是通过这个 qquin 作为参数查询，没有 qquin 就无法获取其他数据，最后无奈，只能关闭站点。主要涉及技术： 描述 技术 平台 .NET 前端框架 ASP .NET 前端技术 Bootstrap , Angular , Font Awesome 后台 C# 数据爬取 Python 高速缓存 Redis 服务器 阿里云 ECS 数据库 MySql ORM Entity Framework 日志 Nlog 域名 www.killteemo.com (已经关闭站点) 域名供应商 西部数据 KillTeemo 的英雄数据，物品数据，皮肤数据等和战绩无关的数据，主要通过 Python 写的爬虫定期爬取英雄联盟官网获得，并且存储到 Redis 缓存中使用，和战绩有关的数据主要通过破解 TGP API 接口获得（现在无法获取 qquin，已失效）。 Github 开源 更多个人项目请通过我的Github查看","link":"/2018/03/02/ProjectKillTeemo/"},{"title":"英雄联盟战绩查询软件","text":"个人项目（2015.07 - 2015.09） LOLData for Rainmeter 是我个人对 Rainmeter 平台开发的英雄联盟战绩插件，数据来源主要来源于当时的 15W 和多玩盒子（现已失效），主要涉及以下技术： 描述 技术 平台 Rainmeter UI 设计 Photoshop , AI 后台逻辑 Inc , Lua 脚本 数据来源 15W，多玩盒子 Github 开源 , Rainmeter 论坛 更多个人项目请通过我的Github查看","link":"/2015/07/02/ProjectLOLDataRainmeter/"},{"title":"扶轮国际社SAAS平台","text":"ThoughtWorks （2019.04.08 ~ 2019.12.31) 我们的客户是国际扶轮（Rotary International，也被称为国际扶轮社），是由分布在 168 个国家和地区中，共超过 30,000 个扶轮社组成的服务性国际组织，总部设于美国伊利诺伊州埃文斯顿。它是一个非政治和非宗教的组织，不分种族、肤色、信仰、宗教、性别或政治偏好，开放给所有人参与。其宗旨为借由汇集各领域的领导人才，提供人道主义服务，促进世界各地的善意与和平。 主要运用技术 Azure 云，K8S，TeamCity，App Configuration，Docker，Helm，Swagger，Dotnet Core 等，因为项目的客户要求保密，所以具体细节不透露。","link":"/2019/12/31/ProjectRotary/"},{"title":"Window 锁屏软件","text":"个人项目（2017.05 - 2017.06） 这个项目是我业余时间写的锁屏软件，现在已经开源（GitHub） 描述 技术 平台 Windows .NET 用户界面 WPF 后端逻辑 C# 更多个人项目请通过我的Github查看","link":"/2017/05/23/ProjectScreenLock/"},{"title":"影视机械臂控制软件","text":"此项目是我架构设计并且编写的项目，通过使用图形化的界面控制六轴机器人达到影视拍摄的目的，与工业六轴机器人操作系统的不同，提供了更完善的交互界面。","link":"/2022/09/04/ProjectUmoco/"},{"title":"淘宝商品自动上架软件","text":"个人外包项目（2018.07 - 2018.11） 主要是帮助他们旗下的淘宝店铺，解决重复性的淘宝后台商品上架，我主要使用 WPF 作为 UI，C#后端，用 Selenium 操作浏览器完成上架过程，只需要设置好商品的价格，类别，主图等信息，系统就会自动批量开始上架，并且有历史记录跟踪和详细的日志，保证流程的完整性。 主要涉及技术： 描述 技术 平台 .NET 用户界面 WPF 后端逻辑 C# 自动化操作组件 Selenium 数据库 Mysql ORM Entity Framework 日志 Nlog 高速缓存 Redis 文档操作 NPOI 服务器 阿里云 ECS 消息件 RabbitMQ 更多个人项目请通过我的Github查看","link":"/2018/07/02/ProjectZonxAutomationSystem/"},{"title":"QT 异形窗口","text":"这段时间在做一款跨平台的 IM 通讯软件，需要 Mac OS 和 Windows 都可以使用，看来我之前的 WPF，UWP 之类的技术栈用不上了，只能在 Electron 或者 QT 之类的跨平台框架中选择了，最终选了 QT，Electron 毕竟是 CEF 框架的产物，使用体验还有开发体验都不如 QT，由于需要高度定制化 UI，所以我没有选择使用系统原生的 TitleBar 和 Windows 样式，这里自己构建一个异形窗体来匹配体验，接下来就说一下如何创建 QT 的异形窗体。 1.创建 BaseTitleBarBaseTitleBar.h 头文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#ifndef BASETITLEBAR_H#define BASETITLEBAR_H#include &lt;QWidget&gt;#include &lt;QLabel&gt;#include &lt;QPushButton&gt;#include &lt;QTimer&gt;enum ButtonType{ MIN_BUTTON = 0, // 最小化和关闭按钮; MIN_MAX_BUTTON , // 最小化、最大化和关闭按钮; ONLY_CLOSE_BUTTON // 只有关闭按钮;};class BaseTitleBar : public QWidget{ Q_OBJECTpublic: BaseTitleBar(QWidget *parent = NULL); ~BaseTitleBar(); // 设置标题栏背景色; void setBackgroundColor(int r, int g, int b); // 设置标题栏图标; void setTitleIcon(QString filePath); // 设置标题内容; void setTitleContent(QString titleContent); // 设置标题栏长度; void setTitleWidth(int width); // 设置标题栏上按钮类型; void setButtonType(ButtonType buttonType); // 设置标题栏中的标题是否会滚动;具体可以看效果; void setTitleRoll(); // 保存/获取 最大化前窗口的位置及大小; void saveRestoreInfo(const QPoint point, const QSize size); void getRestoreInfo(QPoint&amp; point, QSize&amp; size);private: void paintEvent(QPaintEvent *event); void mouseDoubleClickEvent(QMouseEvent *event); void mousePressEvent(QMouseEvent *event); void mouseMoveEvent(QMouseEvent *event); void mouseReleaseEvent(QMouseEvent *event); // 初始化控件; void initControl(); // 信号槽的绑定; void initConnections(); // 加载样式文件; void loadStyleSheet(const QString &amp;sheetName);signals: // 按钮触发的信号; void signalButtonMinClicked(); void signalButtonRestoreClicked(); void signalButtonMaxClicked(); void signalButtonCloseClicked();private slots: // 按钮触发的槽; void onButtonMinClicked(); void onButtonRestoreClicked(); void onButtonMaxClicked(); void onButtonCloseClicked(); void onRollTitle();private: QLabel* m_pIcon; // 标题栏图标; QLabel* m_pTitleContent; // 标题栏内容; QPushButton* m_pButtonMin; // 最小化按钮; QPushButton* m_pButtonRestore; // 最大化还原按钮; QPushButton* m_pButtonMax; // 最大化按钮; QPushButton* m_pButtonClose; // 关闭按钮; // 标题栏背景色; int m_colorR; int m_colorG; int m_colorB; // 最大化，最小化变量; QPoint m_restorePos; QSize m_restoreSize; // 移动窗口的变量; bool m_isPressed; QPoint m_startMovePos; // 标题栏跑马灯效果时钟; QTimer m_titleRollTimer; // 标题栏内容; QString m_titleContent; // 按钮类型; ButtonType m_buttonType;};#endif // BASETITLEBAR_H BaseTitleBar.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295#include &quot;BaseTitleBar.h&quot;#include &lt;QHBoxLayout&gt;#include &lt;QPainter&gt;#include &lt;QFile&gt;#include &lt;QMouseEvent&gt;#include &lt;QDebug&gt;#define BUTTON_HEIGHT 15 // 按钮高度;#define BUTTON_WIDTH 15 // 按钮宽度;#define TITLE_HEIGHT 30 // 标题栏高度;BaseTitleBar::BaseTitleBar(QWidget *parent) : QWidget(parent) , m_colorR(153) , m_colorG(153) , m_colorB(153) , m_isPressed(false) , m_buttonType(MIN_MAX_BUTTON){ initControl(); initConnections(); loadStyleSheet(&quot;MyTitle&quot;);}BaseTitleBar::~BaseTitleBar(){}void BaseTitleBar::initControl(){ m_pIcon = new QLabel; m_pTitleContent = new QLabel; m_pButtonMin = new QPushButton; m_pButtonRestore = new QPushButton; m_pButtonMax = new QPushButton; m_pButtonClose = new QPushButton; m_pButtonMin-&gt;setFixedSize(QSize(BUTTON_WIDTH, BUTTON_HEIGHT)); m_pButtonRestore-&gt;setFixedSize(QSize(BUTTON_WIDTH, BUTTON_HEIGHT)); m_pButtonMax-&gt;setFixedSize(QSize(BUTTON_WIDTH, BUTTON_HEIGHT)); m_pButtonClose-&gt;setFixedSize(QSize(BUTTON_WIDTH, BUTTON_HEIGHT)); m_pButtonClose-&gt;setFlat(true); m_pButtonClose-&gt;setAutoFillBackground(true); m_pButtonClose-&gt;setStyleSheet(&quot;background-color: rgba(255, 255, 255, 0);&quot;); m_pButtonClose-&gt;setIcon(QIcon(&quot;:/new/prefix1/img/close_img.png&quot;)); m_pTitleContent-&gt;setObjectName(&quot;TitleContent&quot;); m_pButtonMin-&gt;setObjectName(&quot;ButtonMin&quot;); m_pButtonRestore-&gt;setObjectName(&quot;ButtonRestore&quot;); m_pButtonMax-&gt;setObjectName(&quot;ButtonMax&quot;); m_pButtonClose-&gt;setObjectName(&quot;ButtonClose&quot;); QHBoxLayout* mylayout = new QHBoxLayout(this); mylayout-&gt;addWidget(m_pIcon); mylayout-&gt;addWidget(m_pTitleContent); mylayout-&gt;addWidget(m_pButtonMin); mylayout-&gt;addWidget(m_pButtonRestore); mylayout-&gt;addWidget(m_pButtonMax); mylayout-&gt;addWidget(m_pButtonClose); mylayout-&gt;setContentsMargins(5, 0, 10, 0); mylayout-&gt;setSpacing(0); m_pTitleContent-&gt;setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed); this-&gt;setFixedHeight(TITLE_HEIGHT); this-&gt;setWindowFlags(Qt::FramelessWindowHint);}void BaseTitleBar::initConnections(){ connect(m_pButtonMin, SIGNAL(clicked()), this, SLOT(onButtonMinClicked())); connect(m_pButtonRestore, SIGNAL(clicked()), this, SLOT(onButtonRestoreClicked())); connect(m_pButtonMax, SIGNAL(clicked()), this, SLOT(onButtonMaxClicked())); connect(m_pButtonClose, SIGNAL(clicked()), this, SLOT(onButtonCloseClicked()));}// 设置标题栏背景色,在paintEvent事件中进行绘制标题栏背景色;//在构造函数中给了默认值，可以外部设置颜色值改变标题栏背景色;void BaseTitleBar::setBackgroundColor(int r, int g, int b){ m_colorR = r; m_colorG = g; m_colorB = b; // 重新绘制（调用paintEvent事件）; update();}// 设置标题栏图标;void BaseTitleBar::setTitleIcon(QString filePath){ QPixmap titleIcon(filePath); m_pIcon-&gt;setPixmap(titleIcon.scaled(25 , 25));}// 设置标题内容;void BaseTitleBar::setTitleContent(QString titleContent){ m_pTitleContent-&gt;setText(titleContent); m_titleContent = titleContent;}// 设置标题栏长度;void BaseTitleBar::setTitleWidth(int width){ this-&gt;setFixedWidth(width);}// 设置标题栏上按钮类型;// 由于不同窗口标题栏上的按钮都不一样，所以可以自定义标题栏中的按钮;// 这里提供了四个按钮，分别为最小化、还原、最大化、关闭按钮，如果需要其他按钮可自行添加设置;void BaseTitleBar::setButtonType(ButtonType buttonType){ m_buttonType = buttonType; switch (buttonType) { case MIN_BUTTON: { m_pButtonRestore-&gt;setVisible(false); m_pButtonMax-&gt;setVisible(false); } break; case MIN_MAX_BUTTON: { m_pButtonRestore-&gt;setVisible(false); } break; case ONLY_CLOSE_BUTTON: { m_pButtonMin-&gt;setVisible(false); m_pButtonRestore-&gt;setVisible(false); m_pButtonMax-&gt;setVisible(false); } break; default: break; }}// 设置标题栏中的标题是否会自动滚动，跑马灯的效果;// 一般情况下标题栏中的标题内容是不滚动的，但是既然自定义就看自己需要嘛，想怎么设计就怎么搞O(∩_∩)O！void BaseTitleBar::setTitleRoll(){ connect(&amp;m_titleRollTimer, SIGNAL(timeout()), this, SLOT(onRollTitle())); m_titleRollTimer.start(200);}// 保存窗口最大化前窗口的位置以及大小;void BaseTitleBar::saveRestoreInfo(const QPoint point, const QSize size){ m_restorePos = point; m_restoreSize = size;}// 获取窗口最大化前窗口的位置以及大小;void BaseTitleBar::getRestoreInfo(QPoint&amp; point, QSize&amp; size){ point = m_restorePos; size = m_restoreSize;}// 绘制标题栏背景色;void BaseTitleBar::paintEvent(QPaintEvent *event){ //设置背景色; QPainter painter(this); QPainterPath pathBack; pathBack.setFillRule(Qt::WindingFill); pathBack.addRoundedRect(QRect(0, 0, this-&gt;width(), this-&gt;height()), 3, 3); painter.setRenderHint(QPainter::SmoothPixmapTransform, true); painter.fillPath(pathBack, QBrush(QColor(m_colorR, m_colorG, m_colorB))); // 当窗口最大化或者还原后，窗口长度变了，标题栏的长度应当一起改变; if (this-&gt;width() != this-&gt;parentWidget()-&gt;width()) { this-&gt;setFixedWidth(this-&gt;parentWidget()-&gt;width()); } QWidget::paintEvent(event);}// 双击响应事件，主要是实现双击标题栏进行最大化和最小化操作;void BaseTitleBar::mouseDoubleClickEvent(QMouseEvent *event){ // 只有存在最大化、还原按钮时双击才有效; if (m_buttonType == MIN_MAX_BUTTON) { // 通过最大化按钮的状态判断当前窗口是处于最大化还是原始大小状态; // 或者通过单独设置变量来表示当前窗口状态; if (m_pButtonMax-&gt;isVisible()) { onButtonMaxClicked(); } else { onButtonRestoreClicked(); } } return QWidget::mouseDoubleClickEvent(event);}// 以下通过mousePressEvent、mouseMoveEvent、mouseReleaseEvent三个事件实现了鼠标拖动标题栏移动窗口的效果;void BaseTitleBar::mousePressEvent(QMouseEvent *event){ if (m_buttonType == MIN_MAX_BUTTON) { // 在窗口最大化时禁止拖动窗口; if (m_pButtonMax-&gt;isVisible()) { m_isPressed = true; m_startMovePos = event-&gt;globalPos(); } } else { m_isPressed = true; m_startMovePos = event-&gt;globalPos(); } return QWidget::mousePressEvent(event);}void BaseTitleBar::mouseMoveEvent(QMouseEvent *event){ if (m_isPressed) { QPoint movePoint = event-&gt;globalPos() - m_startMovePos; QPoint widgetPos = this-&gt;parentWidget()-&gt;pos(); m_startMovePos = event-&gt;globalPos(); this-&gt;parentWidget()-&gt;move(widgetPos.x() + movePoint.x(), widgetPos.y() + movePoint.y()); } return QWidget::mouseMoveEvent(event);}void BaseTitleBar::mouseReleaseEvent(QMouseEvent *event){ m_isPressed = false; return QWidget::mouseReleaseEvent(event);}// 加载本地样式文件;// 可以将样式直接写在文件中，程序运行时直接加载进来;void BaseTitleBar::loadStyleSheet(const QString &amp;sheetName){ QFile file(&quot;:/&quot; + sheetName + &quot;.css&quot;); file.open(QFile::ReadOnly); if (file.isOpen()) { QString styleSheet = this-&gt;styleSheet(); styleSheet += QLatin1String(file.readAll()); this-&gt;setStyleSheet(styleSheet); }}// 以下为按钮操作响应的槽;void BaseTitleBar::onButtonMinClicked(){ emit signalButtonMinClicked();}void BaseTitleBar::onButtonRestoreClicked(){ m_pButtonRestore-&gt;setVisible(false); m_pButtonMax-&gt;setVisible(true); emit signalButtonRestoreClicked();}void BaseTitleBar::onButtonMaxClicked(){ m_pButtonMax-&gt;setVisible(false); m_pButtonRestore-&gt;setVisible(true); emit signalButtonMaxClicked();}void BaseTitleBar::onButtonCloseClicked(){ emit signalButtonCloseClicked();}// 该方法主要是让标题栏中的标题显示为滚动的效果;void BaseTitleBar::onRollTitle(){ static int nPos = 0; QString titleContent = m_titleContent; // 当截取的位置比字符串长时，从头开始; if (nPos &gt; titleContent.length()) nPos = 0; m_pTitleContent-&gt;setText(titleContent.mid(nPos)); nPos++;} 2.创建 BaseWindowBaseWindow.h 12345678910111213141516171819202122232425262728293031#ifndef BASEWINDOW_H#define BASEWINDOW_H#include &lt;QWidget&gt;#include &lt;QMainWindow&gt;#include &quot;BaseTitleBar.h&quot;class BaseWindow : public QWidget{ Q_OBJECTpublic: BaseWindow(QWidget *parent = 0); ~BaseWindow();private: void initTitleBar(); void paintEvent(QPaintEvent *event);private slots: void onButtonMinClicked(); void onButtonRestoreClicked(); void onButtonMaxClicked(); void onButtonCloseClicked();protected: BaseTitleBar* m_titleBar;};#endif // BASEWINDOW_H BaseWindow.cpp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &quot;BaseWindow.h&quot;#include &lt;QDesktopWidget&gt;#include &lt;QApplication&gt;#include &lt;QPainter&gt;#include &lt;QFile&gt;#include &lt;QGraphicsDropShadowEffect&gt;#include &lt;QGridLayout&gt;BaseWindow::BaseWindow(QWidget *parent) : QWidget(parent){ this-&gt;setWindowFlags(Qt::FramelessWindowHint | Qt::WindowMinimizeButtonHint); this-&gt;setAttribute(Qt::WA_TranslucentBackground); initTitleBar();}BaseWindow::~BaseWindow(){}void BaseWindow::initTitleBar(){ m_titleBar = new BaseTitleBar(this); m_titleBar-&gt;move(0, 0); connect(m_titleBar, SIGNAL(signalButtonMinClicked()), this, SLOT(onButtonMinClicked())); connect(m_titleBar, SIGNAL(signalButtonRestoreClicked()), this, SLOT(onButtonRestoreClicked())); connect(m_titleBar, SIGNAL(signalButtonMaxClicked()), this, SLOT(onButtonMaxClicked())); connect(m_titleBar, SIGNAL(signalButtonCloseClicked()), this, SLOT(onButtonCloseClicked()));}void BaseWindow::paintEvent(QPaintEvent* event){ QPainter painter(this); QPainterPath pathBack; pathBack.setFillRule(Qt::WindingFill); pathBack.addRoundedRect(QRect(0, 0, this-&gt;width(), this-&gt;height()), 3, 3); painter.setRenderHint(QPainter::SmoothPixmapTransform, true); painter.fillPath(pathBack, QBrush(QColor(255, 255, 255))); return QWidget::paintEvent(event);}void BaseWindow::onButtonMinClicked(){ if (Qt::Tool == (windowFlags() &amp; Qt::Tool)) { hide(); } else { showMinimized(); }}void BaseWindow::onButtonRestoreClicked(){ QPoint windowPos; QSize windowSize; m_titleBar-&gt;getRestoreInfo(windowPos, windowSize); this-&gt;setGeometry(QRect(windowPos, windowSize));}void BaseWindow::onButtonMaxClicked(){ m_titleBar-&gt;saveRestoreInfo(this-&gt;pos(), QSize(this-&gt;width(), this-&gt;height())); QRect desktopRect = QApplication::desktop()-&gt;availableGeometry(); QRect FactRect = QRect(desktopRect.x() - 3, desktopRect.y() - 3, desktopRect.width() + 6, desktopRect.height() + 6); setGeometry(FactRect);}void BaseWindow::onButtonCloseClicked(){ close();} 3.创建需要继承的窗口我这里因为要设计一个登陆窗体，所以创建了一个 Login 名称的 QWidget Login.h 123456789101112131415161718192021222324#ifndef LOGIN_H#define LOGIN_H#include &lt;QWidget&gt;#include &quot;BaseWindow.h&quot;namespace Ui {class Login;}class Login : public BaseWindow{ Q_OBJECTpublic: explicit Login(QWidget *parent = nullptr); ~Login();private: void initTitleBar(); Ui::Login *ui;};#endif // LOGIN_H Login.cpp 12345678910111213141516171819202122#include &quot;login.h&quot;#include &quot;ui_login.h&quot;Login::Login(QWidget *parent) : BaseWindow(parent), ui(new Ui::Login){ initTitleBar(); ui-&gt;setupUi(this);}Login::~Login(){ delete ui;}void Login::initTitleBar(){ m_titleBar-&gt;setBackgroundColor(255,255,255); m_titleBar-&gt;setButtonType(ONLY_CLOSE_BUTTON); m_titleBar-&gt;setTitleWidth(this-&gt;width());} 4.创建窗体12345678910#include &lt;QApplication&gt;#include &quot;login.h&quot;int main(int argc, char *argv[]){ QApplication a(argc, argv); Login w; w.show(); return a.exec();} 编译之后就可以看到效果了。","link":"/2020/04/29/QT-CustomeWindows/"},{"title":"QT Installer Framework","text":"最近在打包公司的一款 IM 聊天软件给客户使用的时候发现 Https 请求总是失败，但是却在开发机上面运行正常，QT 依赖了 OpenSSL 的运行库来支持 Https 请求，但是我已经把 OpenSSL ToolKit 库 libcrypto-1_1-x64.dll 和 libssl-1_1-x64.dll 拷贝到了软件执行的同级目录里头，但是依然不起作用，客户那边的日志一直都是 TLS initialization failed，后面搜索 Google 查了很多文章，最后找到了答案。 1. 原因 https://bugreports.qt.io/browse/QTBUG-62637 this suggests to me, that, at least for visual studio builds, Qt no longer uses (as of 5.13) openssl for ssl, but rather windows ssl directly. Hence, copying the dlls would likely not doing anymore, except maybe for mingw builds? In either case, at the bottom, “…It’s a new feature in 5.13. You have to configure Qt properly though (it’s not enabled by default on Windows).” I really wish this was explained further, but maybe suggests why it does not work “out of the box” either. If it had, you probably would not have noticed the openssl dll’s weren’t being used. Maybe there is a better/more complete explanation of how ssl works on windows on Qt 5.13, and whether this is true for both mingw and msvc, but I did not find it offhand 上面大概说 QT 从 5.13 开始在 Windows 的运行时不再动态链接 OpenSSL 库了，单纯的拷贝过去已经不起作用了，而是直接链接 Windows SSL 库，但是你却需要正确的配置，才可以链接到 Windows SSL 运行时库，默认是不开启的，查了一圈下来，并没有发现如何配置，最后让客户安装了 OpenSSL x64 应用程序后发现可以正常请求 Https， 所以我猜测，如果安装了 OpenSSL ，他会自动复制 DLL 到 Windows 目录，并且 QT 程序在运行时也不会链接到 Windows SSL 了，而是直接链接到我们安装的 OpenSSL 里头。 使用虚拟机测试了一下，首先一台纯净的刚装上 Windows 1909 18363.1016 版本的虚拟机，直接运行我打包的程序。 已经把 OpenSSL 需要的两个 DLL 复制到了执行文件的同级目录，运行 QLDesktop.exe 登录。 这里的登录会直接向登录 API 发送 https 请求，结果发现报错了，SSL 初始化失败，原因肯定是 OpenSSL 的两个关键 DLL 并没有在运行时链接，然后安装 Win64OpenSSL-1_1_1g.exe 应用，再次运行发现 https 请求正常了，而且就算把根目录的 libcrypto-1_1-x64 和 libssl-1_1-x64 删除掉，也可以正常运行，因为 OpenSSL 在安装的时候自动把这两个 DLL 拷贝到了 C:\\Windows\\System32 中，https 请求在客户机上面无法工作的问题解决了，同时通过大量的 Google 浏览，发现了不少人遇到了这个问题，也同时提供了这几种解决方式： 2. 解决思路 如果自己的 QT 程序是使用 MingW 编译，那可以下载 OpenSSL 的源码，使用 MingW 编译，这样编译出来的应用程序将会使用你根目录下的 OpenSSL DLL。 将 OpenSSL 的安装程序打包到自己的软件安装中。（我们本文将采用这个方式）。 不要使用 QT 的 QNetworkRequest 发送请求，改成直接引用 OpenSSL 源码中 Lib。 3. 思路刨析 因为 Windows 下的 MingW 编译 x64 OpenSSL 问题太多，你可能会遇到无数的兼容性问题或者库问题，之前我编译 Google Protobuf 就深有体会，所以这种方式我们不采取，耗时耗力，还有可能最终没有结果。 这个方式应该是最简单，而且还可以通过 QT Installer 框架定制我们的安装过程。 最直接也是最暴力的方式，直接用 openssl 发送请求，跳过 QT 的封装，虽然也是一个非常不错的思路，但是我最终不采用的原因是因为语法过于复杂，编码过程可能不太好。 4. 认识 QT Installer FrameworkQt5 可以使用官方的 Qt Installer Framework 框架制作安装包 Qt Installer Framework 框架提供了一组工具和实用程序，用于创建一次安装程序，并在所有受支持的桌面 Qt 平台上部署它们，而无需重写源代码。安装程序将在运行它们的平台上具有本机外观：Linux，Microsoft Windows 和 OS X. 安装程序已在以下平台上进行了测试： Microsoft Windows XP 及更高版本 Ubuntu Linux 11.10 及更高版本 OS X 10.7 及更高版本 使用 Qt Installer Framework 框架生成的安装程序，其中包含一组页面，可在安装，更新或卸载过程中指导用户。您需要提供安装的内容并指定有关它的信息，例如产品名称和安装程序以及许可协议的文本。 您可以通过向预定义页面添加小部件或添加整个页面来为用户提供其他选项来自定义安装程序。您可以创建脚本以向安装程序添加操作。 根据您的使用情况，您可以为最终用户提供离线或在线安装程序，或两者兼而有之。 5. 下载 Qt Installer Framework官方下载地址： http://download.qt.io/official_releases/qt-installer-framework/ 我选择的最新版本，然后我们下载 Windows 版本安装。 6. 打包应用这一章节开始分为几个小章节介绍，有点长，请耐心观看。 6.1 windeployqt这是打包应用的第一步，也就是先需要将自己编译的 release 版本和依赖库 都放到一起，让应用程序可以正常运行，当你的 QT 程序编码结束以后，就可以产出 release 版本了。 选择完 release 版本以后，点击菜单栏中的 build，然后在代码库下面就可以看到已经编译好的程序可执行文件了。 但是此时这个应用程序是不包含任何依赖的，如果不把依赖拷贝进来，那只能在你的开发机上面运行，别人的电脑是无法跑起来的，所以我们借助 Qt 提供的部署程序， windeployqt 来自动帮我们把依赖拷贝尽来，windeployqt 命令位于： C:\\Qt\\Qt5.14.2\\5.14.2\\mingw73_64\\bin 如果 powershell 没有找到 windeployqt 命令，请将这个路径放到系统的 path 环境变量中，然后我们 powershell 跳转到这里，运行命令： windeployqt xxxx.exe 至此，QT 已经将我们应用程序所需要的依赖全部拷贝进来了，准备工作就算完成了。","link":"/2020/08/24/QT-Install-Framework/"},{"title":"Rainmeter Lua 脚本","text":"用 Rainmeter 也快 10 年了，从乐此不疲得写 RM 项目到现在的桌面怎么简洁怎么来，期间也发布过不少下载量超六位数 Skin，也没有为 Rainmeter 写过啥，今天写一下 Lua 和 Rainmeter 的使用，也是让大家能运用这个高级脚本写出更好的 Skin。 Script（脚本）这个 Measure 已不是什么新的 Measure 了，但是几乎没有多少中使用到它。可能是它使用的脚本语言门槛比较高的缘故。Rainmeter 官网中的介绍（English）： Rainmeter 官方文档 Measure=Script Measure 就类似于“Plugin” Measure，可以拓展 RM 的功能。但脚本的编写却比 Plugin（使用 C++或 C#编写的 dll）的要简单得多。 在皮肤配置中，lua 脚本语法如下： 123456[MeasureLuaScript]Measure=ScriptScriptFile=MyScript.luaTableName=MyScriptTableMySetting=&quot;SomeSetting&quot;UpdateDivider=1 我解释一下各项参数： Measure=Script标识 Measure 类型是 Script 扩展类型 ScriptFile=MyScript.lua这个参数指定使用的脚本的路径，是必需的 TableName=MyScriptTable这个参数可以是任意值，它是用来与其它的脚本 Measure 区别开来的，所以值是唯一的，也是必需的 MySetting=”SomeSetting”这个参数不是必须的，它是用来向当前使用的 Lua 脚本的传递参数的，参数的名称与数量都要与 Lua 脚本中的表 PROPERTIES 相对应。 脚本中的内容：一个表：用来存放在皮肤中的变量，如上面的 MySettingPROPERTIES={MySetting=””;} UpdateDivider=1更新时间 Lua 必要函数 function Initialize()初始化函数，皮肤刷新时，会调用这个函数 function Update()皮肤每更新更新一次，都会调用这个函数， function GetStringValue()function GetValue()这两个函数有且只能有一个，它的功能是返回字符串（GetStringValue）或数值（GetValue）给皮肤中调用该脚本的 Measure 实例12345678910111213141516171819[Rainmeter]DynamicWindowSize=1Update=1000[MeasureLuaScript]Measure=ScriptScriptFile=#CURRENTPATH#getinistring.luaTableName=GetStringFilePath=&quot;#CURRENTPATH#timesetting.cfg&quot;secName=&quot;time1&quot;KeyName=&quot;h&quot;Defstr=&quot; &quot;[MeterLua]Meter=StringMeasureName=MeasureLuaScriptFontSize=12FontColor=255,255,255,255Solidcolor=0,0,0,100 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859PROPERTIES ={filepath=&quot;&quot;;secName=&quot;&quot;;keyname=&quot;&quot;;defstr=&quot;&quot;;}function Initialize()FilePath =PROPERTIES.filepath;Secstr=PROPERTIES.secName;Keystr=PROPERTIES.keyname;Defstr=PROPERTIES.Defstr;end -- function Initializefunction Update()StrVal=ReadIniFile(FilePath,Secstr,&quot;H&quot;,&quot;0&quot;);end -- function Updatefunction GetStringValue()if not StrVal then StrVal=&quot;can not get anystring!&quot; end ;return StrVal;end -- function GetStringValuefunction ReadIniFile(filename,section,Key,default) local gotsec=false; local i,j=nil,nil; local Keyvalue=nil; if not filename or filename==&quot;&quot; then return &quot;missing \\&quot;filename\\&quot;&quot;; elseif not section or section==&quot;&quot; then return &quot;missing \\&quot;secName\\&quot;&quot;; elseif not Key or Key==&quot;&quot; then return &quot;missing \\&quot;keyName\\&quot;&quot;; end ; section=string.lower(section); Key=string.lower(Key); for tmp in io.lines(filename,r) do tmp=string.lower(tmp); if not gotsec then i,j=string.find(tmp,section..&quot;]&quot;); if i then gotsec=true end; else i,j,Keyvalue=string.find(tmp,Key..&quot;%s*=%s*(.*)%s*&quot;); --print(Keyvalue); if i then break end; end; end; ----io.close(FileN); if not Keyvalue then Keyvalue=default end; return Keyvalue;end 实例中，通过获取 Rainmeter 配置文件。","link":"/2019/02/02/RainmeterLua/"},{"title":"使用Supervisor创建.NET Core守护进程","text":"今天在部署 .NET Core WebAPI 的时候发现一个问题，就是当Linux的Shell停止的时候，我的WebAPI服务也停止了，因为DotNet一直要保持RunTime模式才能让你服务持久化运行，查了一下百度，发现可以通过Linux下的一个服务软件 Supervisor 创建守护进程来持续的让你的服务保持活力。 Supervisorsupervisor管理进程，是通过fork/exec的方式将这些被管理的进程当作supervisor的子进程来启动，所以我们只需要将要管理进程的可执行文件的路径添加到supervisor的配置文件中就好了。此时被管理进程被视为supervisor的子进程，若该子进程异常中断，则父进程可以准确的获取子进程异常中断的信息，通过在配置文件中设置autostart=ture，可以实现对异常中断的子进程的自动重启。 实践接下来，我以我 CentOS 服务器为准，记录如何实现通过 Supervisor 创建我们的 .NET Core 程序的守护进程。 1.安装SupervisorCentOS以及所有Yum管理包的支持的Linux系统通过这个命令安装Supervisor 1sudo yum install supervisor 2.创建Supervisor工作目录1mkdir /etc/supervisor 3.创建Supervisor配置文件1echo_supervisord_conf &gt; /etc/supervisor/supervisord.conf 4.创建任务目录1mkdir /etc/supervisor/conf.d 5.创建配置文件任务目录导入规则在4中，我们创建了一个conf.d的任务目录，这个目录里面放的就是我们的守护进程的任务配置，那么如何让Supervisor 知道我们的任务来自这个文件夹呢？所以我们还需要配置 supervisord.conf 配置文件，导入我们的任务目录 首先： 1vim /etc/supervisor/supervisord.conf 在结尾处添加 12[include]files=conf.d/*.conf 这样 Supervisor 就知道我们的任务来自于这个文件夹，当然这里我是相对路径，你也可以写绝对路径 6.创建守护进程配置文件首先在4中创建的目录下，我们创建一个 xxx.conf 的文件，这个文件就是我们的守护进程详细配置了 1touch test.conf 然后我们配置一下 1234567891011[program:test]command=dotnet TestCore.dlldirectory=/home/lingmin/TestServiceenvironment=ASPNETCORE__ENVIRONMENT=Productionuser=root stopsignal=INTautostart=true autorestart=true startsecs=1 stderr_logfile=/var/log/common.err.logstdout_logfile=/var/log/common.out.log 这里说明一下 参数 参 数 说 明 command 动作，需要执行的命令，dontnet的命令 directory 执行动作的目录，也就是我们发布.NET Core程序的目录 user 执行命令的用户 environment 环境变量，我也没搞懂，保持默认吧 autostart 是否自动随系统启动 autorestart 遇到问题是否自动重启 startsecs 自动重启间隔时间，单位：秒 stderr_logfile 错误日志文件保存目录 stdout_logfile 输出日志文件保存目录 7.制定Supervisor配置文件因为 Supervisor 默认的配置文件其实在 /etc/supervisord.conf 这个文件中，所以我们需要制定我们在3中创建的配置文件为Supervisor的默认配置。 1supervisord -c /etc/supervisor/supervisord.conf 这样我们就指定了我们的配置文件 问题我们在7中制定我们的配置文件的时候，可能会遇到 Error: Another program is already listening on a port that one of our HTTP servers is configured to use. Shut this program down first before starting supervisord.For help, use /usr/bin/supervisord -h 这个错误，这个错误是说我们Supervisor已经在运行了，不能指定配置 所以我们可以通过输入这个命令，来暂时关闭掉 Supervisor 的sock通道 1unlink /tmp/supervisor.sock 然后再输入7中的命令，就可以正常运行了 服务操作（关闭和启动）123456supervisord -c /etc/supervisor/supervisord.conf 启动supervisorctl stop allps -le | grep supervisordps aux | lesskill pid","link":"/2017/03/29/SupervisorDotnerGuardProgress/"},{"title":"Trojan搭建私人VPN","text":"首先先介绍一下 Trojan 是什么？Trojan 可以伪装 HTTPS 数据包，这种机制可帮助您绕过 Great FireWall。Trojan 在 TLS 上具有多种协议，可避免主动/被动检测和 ISP QoS 限制。 Trojan 不是固定程序或协议。 这是一个想法，在某种程度上模仿最常见的服务，使其行为相同，可以帮助您永久性穿越 Great FireWall。 介绍完概念，我们就来说一下如何结合 Trojan 搭建自己的私人 VPN，需要准备如下环境： 国外 VPS 主机 域名 1. VPS 配置首先你需要购买一台国外的 VPS 主机，这里推荐 Vultr 日本节点，靠近中国，速度很快，ping 延迟在 70ms 左右，很适合用来搭建 VPN，购买类型可以参考下图： 付款支持 Palpay，Alipay，信用卡等，购买完成以后，等待服务器初始化完成，你的服务器是这样子的： 记下自己的 IP Address，Username，Password，我们就可以开始下一步了。 2. 域名配置随便找一个域名服务商购买一个很便宜域名，我这里拿 万网 示例，购买结束以后，进入域名解析设置界面，添加一个 A 记录，记录值填写 1 中记录的 VPS IP Address。 3. VPS 安装 TrojanStep1 中我们记下了自己 VPS 的 Username 和 Password，接下来我们随便找一个 SSH 连接工具，这里推荐 Termius 连接上自己的 VPS： 连上以后，我们就可以开始安装 Trojan 了，输入 shell 安装脚本命令（此脚本由atrandys贡献，感谢）： 1curl -O https://raw.githubusercontent.com/atrandys/trojan/master/trojan_centos7.sh &amp;&amp; chmod +x trojan_centos7.sh &amp;&amp; ./trojan_centos7.sh 输入数字 1 开始自动化安装，开始安装以后，会弹出需要绑定到服务的域名，也就是我们在 step2 中注册的 安装结束以后，会提示你需要从自己的 VPS 上面下载一个Trojan-Cli的压缩包，里头就是自动化配置服务生成的域名地址和服务，请下载下来，在下载的时候我们可以用浏览器访问一下自己的域名，会出现这个画面，就代表 Trojan 安装成功。 下载完 Trojan-cli 以后，打开到文件： usr-&gt;src-&gt;trojan-cil-&gt;config.json 记录文件内容中的 password，继续下一步。 4. 启动本地 Trojan 端口监听我们有了自己的 VPS 以后，就需要有一个本地的端口来监听我们访问的网站，如果是需要访问国外站点，我们就要切换路由到我们自己的域名上面，然后由 VPS 访问，再把数据包转发回来。 下载 Trojan，请到这里下载： https://github.com/trojan-gfw/trojan/releases 我是 Macbook，所以用 Mac OS 版本示例，下载完成以后打开目录，然后找到 config.json 配置文件。 把remote_addr修改成自己的域名，password修改成 step3 中记录下的 password。然后启动 start command 脚本 5. 安装 Proxy SwitchyOmegaChrome 安装Proxy SwitchyOmega 插件 1.设置Proxy，点击 Porxy ，设置 default 为 SOCKS5 ，127.0.0.1，1080 端口，点击 Apply changes 2.设置 Auto switch, 第一次进去的时候会有两条默认 rule，删掉，然后添加一条，AutoProxy，Rule List URL（此 Rule LIst 由atrandys贡献，感谢）填写下面的地址： https://raw.githubusercontent.com/atrandys/proV/master/fgfwlist.txt 然后点击 Download Profile Now，点击Apple Changes，大功告成，关闭 Proxy SwitchyOmega 设置界面，回到 Chrome，点击一下Auto Switch 然后就可以访问墙外的世界了 6. 总结总体的流程大概是： VPS 购买和初始化，安装 Trojan 域名购买和 A 记录指向 下载 Trojan 客户端，使用 VPS 生成的密码连接上域名开始代理流量 使用 Proxy SwitchyOmega 进行情景模式切换","link":"/2020/03/03/TrojanVPS/"},{"title":"Typora 图片自动上传阿里OSS","text":"Typora AliyunOSS 运行正常，但不再维护 Typora 近期的新版本带来了图片上传自定义命令的支持，也就是说如果不想使用图床或者 uPic 的同学们，可以自己写命令了，我也是第一时间去对接了这个功能，毕竟我是重度 Typora 使用者，无论是公司的文档还是博客，我都是使用 Typora，当时想了一下应该用什么语言写呢？Java？.NET？C++? 好像都太重了，最后决定用 Shell 或者 Python，但是想了一下 Python 还要装环境，还是直接 Shell 吧，那仓库的选择还是阿里云 OSS 吧，价格便宜安心，现在感觉已经无法信任一些第三方的图床了，图片只有保存在自己云上面才安心，接下来就来说一下如何使用。 下载 请先下载本仓库的 AliyunOssAutoUpload.sh Windows 系统请下载（MacOS 和 Linux 不需要） Git 脚本配置 下载完成后，请打开 shell 文件，然后做如下配置 AliyunOssAutoUpload.sh12345host = &quot;your-oss-host&quot;bucket = &quot;your-oss-bucket&quot;id = &quot;your-oss-AccessKey ID&quot;key = &quot;your-oss-AccessKey Secret Key&quot;cloudFolder = &quot;your-oss-folder&quot; your-oss-host your-oss-bucket your-oss-AccessKey ID your-oss-AccessKey Secret Key your-oss-folder 例如 cloudFolder=”ME” cloudFolder=”ME/Demo” Typora 配置 我这里的示例是当前地址，正确的配置需要绝对地址 需要设置运行权限1chmod 777 AliyunOssAutoUpload.sh MacOS & Linux Typora 的 Command 设置1./AliyunOssAutoUpload-Safety.sh 由于 Windows 缺失 Shell 解释器，所以需要前面安装的 Git，因为 Git 自带 sh 解释器 Windows Typora 的 Command 设置1&quot;C:\\Program Files\\Git\\bin\\sh.exe&quot; &quot;Z:\\Code\\Typora-AliyunOSS-AutoUpload-Shell\\AliyunOssAutoUpload.sh&quot; 测试 完成上面的步骤就可以愉快的使用了，但是保险起见，可以运行一下 Typora 自带的测试工具，就在刚刚的设置页面里头，点击 Test Uploader 开始测试 使用 直接复制图片或者拖动到 Typora 编辑区域，图片将自动完成上传并且引用，这里是哔哩哔哩的视频演示","link":"/2020/05/08/TyporaAutoUploadShell/"},{"title":"VSCode - Setting Sync 设置同步插件","text":"VSCode是Github推广技术 Electron 的产物，可以说是非常强的利用HTML，CSS，JS构建跨平台桌面应用程序框架，微软也让我见识到了：老子拨出一小批人写个“文本编辑器”有多吊。当然，光芒之下的VSCode也有不少需要改进的地方，比如登陆账号能同步设置，因为VSCode的设置项实在太多了，官网至今没有推出，不过借助强大的第三方插件就可以实现 拥有一个github账户。实现同步的功能主要依赖于VSCode插件 “Settings Sync” Setting Sync 可同步包含的所有扩展和完整的用户文件夹 1 .设置文件2 .快捷键设置文件3 .Launch File4 .Snippets Folder5 .VSCode 扩展设置6 .工作空间 Setting Sync 快捷键： 上传： Shift + Alt + U (Sync: Update / Upload Settings) 下载： Shift + Alt + D (Sync: Download Settings) 如果快捷键有冲突，可Ctrl + K + S快捷键设置配置其它快捷键 或 Ctrl + P / F1 在命令窗口输入 &gt;sync 即会出现相应命令供选择 如何使用 Step1 安装 同步插件”Settings Sync” Step2. 进入github -&gt; Settings 在左侧 Developer settings -&gt; Personal access tokens Step3 点击按钮 Generate new token 新增一个token 记住你自己生成的token值，在VSCode配置上回用得到，最好找个笔记保存下来。 Step4 回到VSCode配置将token配置到本地 (Sync: Update / Uplaod Settings) Shift + Alt + U 在弹窗里输入你的token， 回车后会生成syncSummary.txt文件 syncSummary.txt文件会存储VSCode的设置及所安装的插件列表 有点类似package.json这样形式的文件 可以将自己的token分享到自己的团队里面去，这样团队可以共用一套设置。 Step5 设置上同步下载设置 (Sync: Download Settings) Shift + Alt + D 在弹窗里输入你的gist值，稍后片刻便可同步成功 Step6 如果要重置同步设置，变更其它token Ctrl+P / F1 弹出输入&gt;sync,即可重新配置你的其它Token来同步","link":"/2019/01/02/VSCodeSyncPlugin/"},{"title":"WPF 进阶 - Fody PropertyChanged","text":"相信每一个WPF开发工程师都会遇到这样一个问题，将业务转换成业务模型（Model）以后，就需要用相应的视图（VIEW）和视图模型（ViewModel）展示和交互，那么MVVM模式下就必然要做一个头疼的事情，那就是封装响应变化通知的CLR属性，顶级接口为：INotifyPropertyChanged 我们先看如何自己实现一个INotifyPropertyChanged的通知事件 123456789101112public class MainViewModel : INotifyPropertyChanged{ public event PropertyChangedEventHandler PropertyChanged; private void OnPropertyChanged(string propertyName) { if (this.PropertyChanged != null) this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName)); }} 所有需要通知UI的CLR属性都需要响应这个方法 123456789101112131415private string _appName;public string AppName{ get { return _appName; } set { if (_appName == value) return; _appName = value; OnPropertyChanged(nameof(AppName)); }} 这样的写法，一个两个属性还好，在有很多属性的情况下，就显得有一些繁杂，今天要介绍一款开源的工具就是为了解决这个问题。 Fody PropertyChanged 使用方法： 使用方法通过Nuget安装 PM&gt; Install-Package PropertyChanged.Fody 安装完成后，会在项目中，添加FodyWeavers.xml文件，这是Fody的配置文件，详细可以参考 Fody 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;Weavers&gt; &lt;PropertyChanged /&gt;&lt;/Weavers&gt; 说明项目中所有标记有[AddINotifyPropertyChangedInterface]特性，或者实现了INotifyPropertyChanged的类，都将自动在其属性中实现通知相关的代码，除非属性被显示标记为不通知 1234567891011121314[AddINotifyPropertyChangedInterface]public class Person { public string GivenNames { get; set; } public string FamilyName { get; set; } public string FullName { get { return string.Format(&quot;{0} {1}&quot;, GivenNames, FamilyName); } }} 特性说明： 1.AlsoNotifyForAttribute 允许注入指向不同属性的通知代码。例如 123456789101112public class Person : INotifyPropertyChanged{ [AlsoNotifyFor(&quot;FullName&quot;)] public string GivenName { get; set; } [AlsoNotifyFor(&quot;FullName&quot;)] public string FamilyName { get; set; } public event PropertyChangedEventHandler PropertyChanged; public string FullName { get; set; }} 2.DoNotNotifyAttribute 使用此属性可以从注入通知中排除属性或类型。例如 1234567public class Person : INotifyPropertyChanged{ public string GivenName { get; set; } [DoNotNotify] public string FamilyName { get; set; } public event PropertyChangedEventHandler PropertyChanged;} 3.DependsOnAttribute 注入此属性以在设置依赖属性时通知。 例如 1234567891011public class Person : INotifyPropertyChanged{ public string GivenName { get; set; } public string FamilyName { get; set; } public event PropertyChangedEventHandler PropertyChanged; [DependsOn(&quot;GivenName&quot;,&quot;FamilyName&quot;)] public string FullName { get; set; }} 4.DoNotSetChangedAttribute 用于忽略IsChanged给定的属性。 例如IsChanged，FullName设置时不会调用以下示例。 12345678public class Person: INotifyPropertyChanged{ [DoNotSetChanged] public string FullName { get; set; } public bool IsChanged { get; set; } public event PropertyChangedEventHandler PropertyChanged;} 5.DoNotCheckEqualityAttribute 用于跳过给定属性的相等性检查。","link":"/2019/01/08/WPF-AOP-fody-propertychanged/"},{"title":"WPF MarkupExtension 原理","text":"存在一些不是特定于XAML的WPF实现的标记扩展，而是XAML作为语言的内在函数或特征的实现。这些标记扩展在System.Xaml程序集中实现，作为一般.NET Framework XAML服务的一部分，并且位于XAML语言XAML命名空间内。在Xaml中为某个对象以Attribute的方式设置对象的属性时，attribute的值默认只能是字符串。 例如： 1&lt;TextBlock Text=&quot;Text&quot;/&gt; 上面为Text属性设置值”Text”。如果属性的类型为String(如上面代码中的Text属性)，这是没有问题的。但是如果属性的类型不是String，比如Foreground属性，它的类型是Brush。我们发现Xaml中仍然是可以通过设置一个字符串来完属性赋值的。例如： 1&lt;TextBlock Foreground=&quot;Aqua&quot; Text=&quot;Foreground&quot;/&gt; 这是因为BCL为Brush类型定义了一个TypeConverter: BrushConverter. 它会在运行时将字符串转换成一个Brush结构。如果我们要在Xaml中直接给Foreground属性传递一个Brush对象怎么办呢？这就到了MarkupExtension发挥作用的时候了。它的作用就是扩充了Attribute方式赋值时只能赋给字符串的限制。让在赋值的时候可以执行后台代码从而产生所期望的对象。其实我们经常用的Binding,StaticResource,DynamicResource等都是属于MarkupExtension. 上代码： 先看一下使用MarkupExtension后xaml的效果： 1234567891011121314&lt;Window x:Class=&quot;WPFSample.Samples.MarkupExtensionSample&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:me=&quot;clr-namespace:WPFSample.Samples.MarkupExtensionSamples&quot; Title=&quot;MarkupExtensionSample&quot; Height=&quot;300&quot; Width=&quot;300&quot;&gt; &lt;Grid&gt; &lt;StackPanel&gt; &lt;TextBlock Foreground=&quot;Aqua&quot; Text=&quot;Foreground&quot;/&gt; &lt;!--Following xaml code set a foreground using markup extension.--&gt; &lt;TextBlock Foreground=&quot;{me:BrushGetter TitleBrush}&quot; Text=&quot;Foreground from markup extension&quot;/&gt; &lt;TextBlock Foreground=&quot;{me:BrushGetter ContentBrush}&quot; Text=&quot;Foreground from markup extension&quot;/&gt; &lt;/StackPanel&gt; &lt;/Grid&gt;&lt;/Window&gt; 再看看BrushGetter的定义: 123456789101112131415161718192021222324252627public class BrushGetter : MarkupExtension { private string _brushName; public BrushGetter(string brushName) { //在Xaml中使用该MarkupExtension时传递brushName参数。 _brushName = brushName; } public override object ProvideValue(IServiceProvider serviceProvider) { //当在通过该MarkupExtension在Xaml中给属性赋值时，该方法将被调用。根据条件返回一个合适的对象即可。 //至于参数serviceProvider,一般情况下用不到。暂时不纠结它了。 switch (_brushName) { case &quot;TitleBrush&quot;: return Brushes.Black; case &quot;ContentBrush&quot;: return Brushes.Blue; default: break; } return null; } } 其实使用MarkupExtension来赋值时，运行时会在每次赋值时构造一个Markup Extension对象，传递xaml中定义的参数，然后调用ProvideValue方法获取一个值。","link":"/2019/01/03/WPF-markupextension/"},{"title":"WPF MarkupExtension 实践","text":"我们首先来回顾一下上一篇中 MarkupExtension 的一些基础的概念，首先当然是 XAML 了，XAML 全称是 Extensible Application Markup Language (可扩展应用程序标记语言)，是专门用于 WPF 技术中的 UI 设计语言，通过使用 XAML 语言，我们能够快速设计软件界面，同时能够通过绑定这种机制能够很好地实现界面和实现逻辑之间的解耦，这个就是 MVVM 模式的核心了。 Markup Extension，顾名思义，就是对 xaml 的扩展，在 XAML 中，规定如果属性以{}开始及结束，就是 Markup Extension，Markup Extension 指的是继承于 MarkupExtension 的类，首先我们通过一张图来看看 WPF 中有哪些已知的 Markup Extension。 看了这张图片之后是不是对这个 MarkupExtension 有一个常规的认识，你会发现这个在 WPF 中实在是太重要了，通过这个 MarkupExtension 我们能够实现绑定、资源等等一系列的操作，在介绍完这个之后，我们来看看，这个抽象的 MarkupExtension 基类到底是什么？里面包含些什么？怎么去使用它？ 123456789101112131415161718192021222324using System;namespace System.Windows.Markup{ // 摘要: // 为所有 XAML 标记扩展提供基类。 public abstract class MarkupExtension { // 摘要: // 初始化从 System.Windows.Markup.MarkupExtension 派生的类的新实例。 protected MarkupExtension(); // 摘要: // 在派生类中实现时，返回一个对象，此对象被设置为此标记扩展的目标属性的值。 // // 参数: // serviceProvider: // 可以为标记扩展提供服务的对象。 // // 返回结果: // 将在扩展应用到的属性上设置的对象值。 public abstract object ProvideValue(IServiceProvider serviceProvider); }} 其实看看里面的内容，仅仅提供了一个抽象的方法 ProvideValue，我们在继承这个抽象类后需要去重载这个抽象方法，然后来实现自己的逻辑。 在对整个 MarkupExtension 介绍之后，我们可以对它进行一个总结，那就是 XAML 标记扩展语法格式： &lt;元素对象 对象属性=”{扩展标记 扩展标记属性 = 扩展属性值}” /&gt; 这个是不是很熟悉，如果还是不够直观的话，我们可以通过代码来进行说明： 12345&lt;MenuItem Header=&quot;New&quot;&gt; &lt;MenuItem.Icon&gt; &lt;Image Source=&quot;data/cat.png&quot;/&gt; &lt;/MenuItem.Icon&gt;&lt;/MenuItem&gt; 这个是 MSDN 介绍的常规方式，在这里我们可以通过三种不同的方式来达到这个目的，具体来看看是怎么实现的吧？ 123456789101112131415161718192021222324252627&lt;Menu Grid.Column=&quot;0&quot;&gt; &lt;MenuItem Header=&quot;文本&quot;&gt; &lt;MenuItem Header=&quot;重做&quot;&gt; &lt;MenuItem.Icon&gt; &lt;Image Stretch=&quot;Uniform&quot; Source=&quot;{extension:ImageBinding Redo}&quot;&gt;&lt;/Image&gt; &lt;/MenuItem.Icon&gt; &lt;/MenuItem&gt; &lt;MenuItem Header=&quot;撤销&quot;&gt; &lt;MenuItem.Icon&gt; &lt;Image Stretch=&quot;Uniform&quot; Source=&quot;{extension:ImageBinding Undo}&quot;&gt;&lt;/Image&gt; &lt;/MenuItem.Icon&gt; &lt;/MenuItem&gt; &lt;MenuItem Header=&quot;保存所有&quot;&gt; &lt;MenuItem.Icon&gt; &lt;Image Stretch=&quot;Uniform&quot; Source=&quot;{Binding SaveAll,Converter={StaticResource SourceConverter}}&quot;&gt;&lt;/Image&gt; &lt;/MenuItem.Icon&gt; &lt;/MenuItem&gt; &lt;MenuItem Header=&quot;测试&quot;&gt; &lt;MenuItem.Icon&gt; &lt;Image Stretch=&quot;Uniform&quot; Source=&quot;Resources/Images/Redo.png&quot;&gt;&lt;/Image&gt; &lt;/MenuItem.Icon&gt; &lt;/MenuItem&gt; &lt;/MenuItem&gt; &lt;MenuItem Header=&quot;编辑&quot;&gt;&lt;/MenuItem&gt; &lt;MenuItem Header=&quot;视图&quot;&gt;&lt;/MenuItem&gt; &lt;MenuItem Header=&quot;插件&quot;&gt;&lt;/MenuItem&gt; &lt;/Menu&gt; 第一种方式就是我们今天重点介绍的通过继承 MarkupExtension 来实现同样的效果，我们来具体分析一下这个 ImageBinding 123456789101112131415161718192021222324252627282930313233343536public class ImageBindingExtension : System.Windows.Markup.MarkupExtension { public ImageBindingExtension(string path) : this() { Path = path; } public ImageBindingExtension() { } [ConstructorArgument(&quot;path&quot;)] public string Path { get; set; } public override object ProvideValue(IServiceProvider serviceProvider) { IProvideValueTarget target = serviceProvider.GetService(typeof(IProvideValueTarget)) as IProvideValueTarget; if (target.TargetObject is Setter) { return new Binding(Path) { Converter = ImgaeSourceConverter.Default }; } else { Binding binding = new Binding(Path) { Converter = ImgaeSourceConverter.Default }; return binding.ProvideValue(serviceProvider); } } } 这里面我们定义的 Path 属性就是绑定到 ViewModel 中的一个特定的属性，这里我们通过重写 ProvideValue 方法，最终调用 BindingBase 的 ProvideValue 返回 ImageSource 对象，这里是通过一个转换器来实现源属性(字符串)到目标属性 ImageSource 的转换的，我们会发现，其实这种方法和直接绑定并设置转换器其实效果是一样的，只不过第一种方式更为直观，将所有的转换过程都放在了重写 ProvideValue 函数的过程中了，这个读者在后面可以对照 demo 去认真思考然后加以总结。 示例 2：通过 MarkupExtension 绑定到 ListBox 的 ItemsSource 属性 这个稍微复杂一些，我们在 Reflection 这个 MarkupExtension 中加入了一些自定义的属性，这些属性能够控制后面返回的数据源的最终内容，其实这个也是非常好理解的，我们在定义 RelativeSource 这个 MarkupExtension 的时候，也是通过定义 Mode、AncestorType、AncestorLevel 等属性组合起来最终实现在视觉树上找到最终的元素。在代码里面也不复杂主要是通过反射来获取 Button 的属性、方法、事件、字段等等，这个具体的实现过程可以参考后面的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class ReflectionExtension : System.Windows.Markup.MarkupExtension { public Type CurrentType { get; set; } public bool IncludeMethods { get; set; } public bool IncludeFields { get; set; } public bool IncludeEvents { get; set; } public ReflectionExtension(Type currentType) { this.CurrentType = currentType; } public override object ProvideValue(IServiceProvider serviceProvider) { if (this.CurrentType == null) { throw new ArgumentException(&quot;Type argument is not specified&quot;); } ObservableCollection&lt;string&gt; collection = new ObservableCollection&lt;string&gt;(); foreach (PropertyInfo p in this.CurrentType.GetProperties()) { collection.Add(string.Format(&quot;属性 : {0}&quot;, p.Name)); } if (this.IncludeMethods) { foreach (MethodInfo m in this.CurrentType.GetMethods()) { collection.Add(string.Format(&quot;方法 : {0} with {1} argument(s)&quot;, m.Name, m.GetParameters().Count())); } } if (this.IncludeFields) { foreach (FieldInfo f in this.CurrentType.GetFields()) { collection.Add(string.Format(&quot;字段 : {0}&quot;, f.Name)); } } if (this.IncludeEvents) { foreach (EventInfo e in this.CurrentType.GetEvents()) { collection.Add(string.Format(&quot;事件 : {0}&quot;, e.Name)); } } return collection; } } 今天就如何自定义 MarkupExtension 做了一个简单的介绍，最重要的是能够通过这种方式来实现自己的合理绑定的目的，同时通过这种合理的扩展方式也能够让我们的代码更加灵活多变","link":"/2019/01/05/WPFMarkupExtension/"},{"title":"WPF 代码生成绑定 DataTemplate","text":"前几天在做 .NET WPF项目的时候，有这样一个需求，在 自定义控件 的 样式文件 里面需要为一个 ListBox 绑定 DataTemplate 模板，而且在模板里面有一个Viewbox ，更变态的是，需要绑定一个鼠标左键单击事件，我们都知道自定义控件的 主题样式文件（视图XAML） 是无法访问到控件类的，这一下子就把我给难住了，后来一想，看来只能在控件类里面操作了。 1 . 获得样式文件的控件对象Ⅰ怎么才可以在控件类中获得样式文件中的 控件对象 呢，这个还是很简单的，首先为控件创建一个类型相同的 UIElement对象 ，我这里是 ListBox 1private ListBox _cameraListBox; Ⅱ然后设置一个 只读 的控件名称，用于绑定到样式文件中 1private const string Parid_cameraListBox = nameof(Parid_cameraListBox); Ⅲ再 标识 模板化的已命名部件 1[TemplatePart ( Name = Parid_cameraListBox ) ] Ⅳ然后在 样式文件 中为控件的 x:Name 绑定上 II 步骤的名称： 12345&lt;ListBox x:Name=&quot;Parid_cameraListBox&quot; ScrollViewer.CanContentScroll=&quot;True&quot; Style=&quot;{StaticResource ListBoxStyCarmera}&quot;&gt;&lt;/ListBox&gt; Ⅴ重写控件类中的 OnApplyTemplate 方法 12345678public override void OnApplyTemplate(){ if ((_cameraListBox = GetTemplateChild(Parid_cameraListBox) as ListBox) != null) { Binding binding = new Binding(nameof(HistoryVideoSources)) { Source = this }; _cameraListBox.SetBinding(ListBox.ItemsSourceProperty, binding); }} 这样就可以在 控件类 中拿到 样式视图 里面的控件对象了 2 . 代码生成绑定DateTemplate正如上面所说，为什么我要在后端生成绑定DataTemplate 因为我需要绑定事件，接下来就说说如何为 ListView 用 C# 代码的方式绑定上数据模板。 Ⅰ通过查看 DataTemplate 的从元数据，发现它是继承自 FrameworkTemplate，这个类有一个名为 VisualTree 类型为 FrameworkElementFactory 的属性，那这样就好很解决了，因为其实数据模板里面的每一个子控件 其实都是一个 FrameworkElementFactory 对象，废话不多说，开写： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/// &lt;summary&gt;/// 初始化下载数据模板/// &lt;/summary&gt;private void Down_ListBox_Template () { DataTemplate dataTemplate = new DataTemplate (); FrameworkElementFactory topElement = CreateTopElement (); FrameworkElementFactory downPath = CreatePathElement (GeometryDown, &quot;下载历史&quot;); FrameworkElementFactory downViewBox = CreateViewBoxElement (VideoAxisActionType.Dwon.ToString (), downPath); topElement.AppendChild (downViewBox); FrameworkElementFactory favoritePath = CreatePathElement (GeometryFavorite, &quot;收藏历史&quot;); FrameworkElementFactory favoriteViewBox = CreateViewBoxElement (VideoAxisActionType.Favorite.ToString (), favoritePath); topElement.AppendChild (favoriteViewBox); FrameworkElementFactory openPath = CreatePathElement (GeometryOpen, &quot;打开视频&quot;); FrameworkElementFactory openViewBox = CreateViewBoxElement (VideoAxisActionType.Open.ToString (), openPath); topElement.AppendChild (openViewBox); dataTemplate.VisualTree = topElement; _downButtonListBox.ItemTemplate = dataTemplate;}/// &lt;summary&gt;/// 创建顶层数据模板容器/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;private FrameworkElementFactory CreateTopElement () { FrameworkElementFactory frameworkElementFactory = new FrameworkElementFactory (typeof (StackPanel)); frameworkElementFactory.SetValue (StackPanel.HeightProperty, 16.00); frameworkElementFactory.SetValue (StackPanel.MarginProperty, new Thickness (0, 3, 5, 1)); frameworkElementFactory.SetValue (StackPanel.OrientationProperty, Orientation.Horizontal); return frameworkElementFactory;}/// &lt;summary&gt;/// 创建Path元素模板/// &lt;/summary&gt;/// &lt;param name=&quot;GeometryPath&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;ToolTipStr&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private FrameworkElementFactory CreatePathElement (string GeometryPath, string ToolTipStr) { FrameworkElementFactory path = new FrameworkElementFactory (typeof (Path)); path.SetValue (CursorProperty, Cursors.Hand); path.SetValue (Path.DataProperty, Geometry.Parse (GeometryPath)); path.SetValue (Path.FillProperty, new SolidColorBrush ((Color) ColorConverter.ConvertFromString (&quot;#c8c7c3&quot;))); path.SetValue (ToolTipProperty, ToolTipStr); return path;}/// &lt;summary&gt;/// 创建ViewBox元素模板/// &lt;/summary&gt;/// &lt;param name=&quot;NameStr&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;thick&quot;&gt;&lt;/param&gt;/// &lt;param name=&quot;pathChild&quot;&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private FrameworkElementFactory CreateViewBoxElement (string NameStr, FrameworkElementFactory pathChild) { FrameworkElementFactory viewBox = new FrameworkElementFactory (typeof (Viewbox)); viewBox.SetValue (HeightProperty, 14.00); viewBox.SetValue (WidthProperty, 14.00); viewBox.SetValue (MarginProperty, new Thickness (10, 0, 0, 2)); viewBox.SetValue (NameProperty, NameStr); viewBox.AddHandler (MouseLeftButtonDownEvent, new MouseButtonEventHandler (viewBox_LeftMouseButtonDown)); viewBox.AppendChild (pathChild); return viewBox;} 上面我们声明了一个 DataTemplate 对象，然后开始创建各种 子控件 其实这里没有什么好说的，都是一些设置属性和层叠控件，需要多少层，就创建多少层，然后按照顺序把他们依次通过 AppendChild 方法添加进去，最后把 顶层 的 FrameworkElementFactory 对象赋值给数据模板的 VisualTree 属性就可以了，最后一步就是就是： 1_downButtonListBox.ItemTemplate = dataTemplate; 把我们声明的数据模板项给对应控件的ItemTemplate属性就可以了 3 . 事件绑定Ⅰ上面我们介绍了，如何用代码去构建一个DataTemplate，那么怎么绑定事件呢，FrameworkElementFactory 类，有一个 AddHandler 重载方法： 12public void AddHandler(RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);public void AddHandler(RoutedEvent routedEvent, Delegate handler); 参 数 名 类 型 说 明 routedEvent RoutedEvent 路由事件的标识 handler Delegate 对处理程序实现的委托事件 handledEventsToo bool 标记为路由的事件处理, 默认值为 false 前两个参数不用说了，一个 路由事件标识 一个 具体的委托事件 ，重点说一下最后一个参数 handledEventsToo ，我们都知道 WPF 的 路由事件 的路由策略如果设置为 Bubble 那么这个路由事件会一直沿着 可视树 向上传递，所以需要一个标识来表示这个事件是否已经被处理，那么 handledEventsToo 这个参数就担任了这个标识的作用。 Ⅱ其实我觉得到这里可以结束了，但是还是说一下具体如何绑定事件吧： 1viewBox.AddHandler(MouseLeftButtonDownEvent, new MouseButtonEventHandler(viewBox_LeftMouseButtonDown)); 这里的 viewBox 就是一个 FrameworkElementFactory 对象，通过AddHandler方法就可以绑定事件了。 如果还是有疑问可以看一下这个项目：WPF实现的类似Adobe AE时间轴的控件","link":"/2017/04/23/WPF_Code_generate_template/"},{"title":"Xamarin Android ListView","text":"之前写 WPF 的时候，自定义 ListView 可以非常轻松的就实现，无论是通过DataTemplate还是 ItemTemplate都可以达到预期效果，但是 Xamarin Android 就比较复杂了。 创建自定义布局创建自定义行布局四个内置行视图是非常简单。 要显示更复杂的布局 （如电子邮件或推文或联系信息的列表） 将需要自定义视图。 自定义视图通常声明为 AXML 文件资源/布局目录，然后再加载，使用其资源的自定义适配器的 Id。 该视图可以包含任意数量的显示类 （如 TextViews、 ImageViews 和其他控件） 使用自定义颜色、 字体和布局。 此示例与前面的示例通过多种方式不同： 继承自 Activity，而不 ListActivity。 你可以为任何自定义行 ListView，但也可以在包含其他控件 Activity 布局 （如标题、 按钮或其他用户界面元素）。 此示例将上面的标题 ListView 来说明。 屏幕; 需要一个 AXML 布局文件在前面的示例 ListActivity 不需要的布局文件。 包含此 AXMLListView 控制声明。需要一个 AXML 布局文件，可呈现每个行。 此 AXML 文件包含自定义字体和颜色设置的文本和图像控件。使用可选的自定义选择器 XML 文件选择此项时设置的行的外观。 ItemClick 必须以不同的方式声明 (事件处理程序附加到 ListView.ItemClick 而不是重写 OnListItemClick 中 ListActivity)。 这些更改下面详细介绍，开始创建活动的视图和自定义行视图，然后介绍对适配器和活动来呈现它们的修改。将 ListView 添加到活动布局 因为 HomeScreen 不再继承 ListActivity 它没有默认视图中，因此必须为 HomeScreen 的视图创建布局 AXML 文件。 对于此示例，该视图将有一个标题 (使用 TextView) 和一个 ListView 以显示数据。 在中定义布局 Resources/Layout/HomeScreen.axml 文件如下所示： 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/Heading&quot; android:text=&quot;Vegetable Groups&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#00000000&quot; android:textSize=&quot;30dp&quot; android:textColor=&quot;#FF267F00&quot; android:textStyle=&quot;bold&quot; android:padding=&quot;5dp&quot; /&gt; &lt;ListView android:id=&quot;@+id/List&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;fill_parent&quot; android:cacheColorHint=&quot;#FFDAFF7F&quot; /&gt;&lt;/LinearLayout&gt; 使用的好处 Activity 与自定义布局 (而不是 ListActivity) 在于能够将其他控件添加到屏幕上，如标题 TextView 在此示例中。创建自定义行布局另一个 AXML 布局文件需包含会在列表视图中显示每个行的自定义布局。 在此示例中的行，将有绿色背景、 棕色、 文本和右对齐图像。 Android XML 标记来声明此布局中所述 Resources/Layout/CustomView.axml: 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;fill_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#FFDAFF7F&quot; android:padding=&quot;8dp&quot;&gt; &lt;LinearLayout android:id=&quot;@+id/Text&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:paddingLeft=&quot;10dip&quot;&gt; &lt;TextView android:id=&quot;@+id/Text1&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textColor=&quot;#FF7F3300&quot; android:textSize=&quot;20dip&quot; android:textStyle=&quot;italic&quot; /&gt; &lt;TextView android:id=&quot;@+id/Text2&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:textSize=&quot;14dip&quot; android:textColor=&quot;#FF267F00&quot; android:paddingLeft=&quot;100dip&quot; /&gt; &lt;/LinearLayout&gt; &lt;ImageView android:id=&quot;@+id/Image&quot; android:layout_width=&quot;48dp&quot; android:layout_height=&quot;48dp&quot; android:padding=&quot;5dp&quot; android:src=&quot;@drawable/icon&quot; android:layout_alignParentRight=&quot;true&quot; /&gt;&lt;/RelativeLayout &gt; 而自定义行布局可以包含许多不同的控件，滚动性能可能受到复杂的设计和使用映像 （尤其是如果他们有要通过网络加载）。 有关解决滚动性能问题，请参阅 Google 的文章了解详细信息。引用自定义行视图自定义适配器示例的实现 HomeScreenAdapter.cs。 关键方法是 GetView，它会加载自定义 AXML 使用的资源 ID Resource.Layout.CustomView，然后在每个视图，然后再返回它在控件上设置属性。 完整的适配器类所示： 123456789101112131415161718192021222324252627282930313233public class HomeScreenAdapter : BaseAdapter&lt;TableItem&gt; { List&lt;TableItem&gt; items; Activity context; public HomeScreenAdapter(Activity context, List&lt;TableItem&gt; items) : base() { this.context = context; this.items = items; } public override long GetItemId(int position) { return position; } public override TableItem this[int position] { get { return items[position]; } } public override int Count { get { return items.Count; } } public override View GetView(int position, View convertView, ViewGroup parent) { var item = items[position]; View view = convertView; if (view == null) // no view to re-use, create new view = context.LayoutInflater.Inflate(Resource.Layout.CustomView, null); view.FindViewById&lt;TextView&gt;(Resource.Id.Text1).Text = item.Heading; view.FindViewById&lt;TextView&gt;(Resource.Id.Text2).Text = item.SubHeading; view.FindViewById&lt;ImageView&gt;(Resource.Id.Image).SetImageResource(item.ImageResourceId); return view; }} 引用活动中自定义的 ListView因为 HomeScreen 类现在继承自 Activity、ListView 要保存对 AXML 中声明的控件的引用的类中声明字段： ListView listView; 然后，类必须加载活动的自定义布局 AXML 使用 SetContentView 方法。 然后，它可以找到 ListView 布局中的控件然后创建并分配该适配器并分配的单击处理程序。 OnCreate 方法中的代码如下所示： 123456SetContentView(Resource.Layout.HomeScreen); // loads the HomeScreen.axml as this activity's viewlistView = FindViewById&lt;ListView&gt;(Resource.Id.List); // get reference to the ListView in the layout// populate the listview with datalistView.Adapter = new HomeScreenAdapter(this, tableItems);listView.ItemClick += OnListItemClick; // to be defined 最后 ItemClick 必须定义处理程序; 在这种情况下它只是显示 Toast 消息： 123456void OnListItemClick(object sender, AdapterView.ItemClickEventArgs e){ var listView = sender as ListView; var t = tableItems[e.Position]; Android.Widget.Toast.MakeText(this, t.Heading, Android.Widget.ToastLength.Short).Show();}","link":"/2019/02/10/Xamarin-listview/"},{"title":"AOP(一) 静态拦截","text":"AOP为 Aspect Oriented Programming 的缩写，意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术，AOP是OOP的延续，AOP是一种模式，Gregor Kiczales 在1997年领导一队研究人员首次介绍了AOP。当时他们关心的问题是如何在大型面向对象的代码库中重复使用那些必要且代价高的样板，那些样板的通用例子具有日志，缓存和事务功能。 概览推动 AOP 模式的重要因素之一就是开发人员开始关注 OOP 模式中的切面关注点，关注点是一个系统中的功能片段， 优势 1.将通用功能从业务逻辑中抽离，避免重复性劳动，易维护。2.模块化，降低架构耦合度，复杂度。3.非侵入式代码，保持良好的代码健壮 1.静态拦截已最简单的静态拦截为例，理解 AOP 的模式。 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class User { public User() =&gt; this.PostTime = DateTime.Now; public string Name { get; set; } public string Password { get; set; } public DateTime PostTime { get; set; } } public interface IMakeProcessor { void Output(User user); } public class MakeProcessor : IMakeProcessor { public void Output(User user) =&gt; Console.WriteLine($&quot;&gt; 用户：{user.Name}，请求时间：{user.PostTime.ToShortDateString()}&quot;); } public class MakeProcessorDecorator : IMakeProcessor { public IMakeProcessor makeProcessor { get; set; } public MakeProcessorDecorator(IMakeProcessor makeProcessor) =&gt; this.makeProcessor = makeProcessor; public void Output(User user) { Pre(user); makeProcessor.Output(user); Pred(user); } public void Pre(User user) { Console.WriteLine(&quot;\\n\\n&gt; 正在登陆，校验用户中. . . . . .&quot;); if(!user.Password.Equals(&quot;123456&quot;)) { Console.WriteLine(&quot;&gt; 密码错误 ! (401)&quot;); } else { Console.WriteLine(&quot;&gt; 登陆成功 ! (200)&quot;); } } public void Pred(User user) { Console.WriteLine(&quot;&gt; 登陆请求结束，进行日志记录. . . . . .&quot;); } } class Program { static void Main(string[] args) { User user1 = new User() { Name = &quot;user1&quot;, Password = &quot;123&quot; }; User user2 = new User() { Name = &quot;user2&quot;, Password = &quot;123456&quot; }; IMakeProcessor makeProcessor = new MakeProcessorDecorator(new MakeProcessor()); makeProcessor.Output(user1); makeProcessor.Output(user2); Console.ReadLine(); } } 我们通过一个 MakeProcessorDecorator 类，去代理 MakeProcessor 实现了静态的拦截。 上面代码看起来还不错，但是也仅限于这个Demo，真正的生产环境中，我们需要对数据进行校验，还要进行日志记录，还要考虑多种环境，如断线重连啊，请求失败啊。。。。。那有100个甚至1000个这种业务类，我们都要去构建一个代理类，那是不是想死的心都有了，所以这篇文章只是让大家理解 AOP 的模式，这样的写法很愚蠢，并不会应用到实际开发中。","link":"/2017/01/13/aop1/"},{"title":".NET框架到底是什么？","text":"最近在面试大厂中，面试官频繁的问到一个问题，**.NET 框架是什么？怎么运行？**可以详细解释一下吗？还好之前看过《CLR VIA C#》这本著作，还是可以回答上的，现在想通过这次机会写一篇系统的文章来介绍一下。 1. 序章我们从最简单的一个 C# Hello World 开始我们的长篇大论，打开你的 Visual Studio，新建一个 C# Framework Console 控制台程序，输入学习每个语言的第一步“Hello World” 123456789101112using System;namespace ConsoleApp1{ class Program { static void Main(string[] args) { Console.WriteLine(&quot;Hello World&quot;); } }} 点击 VS Debug 运行，你不会看到 Hello world，控制台程序会一闪而过然后 VS 结束调试，因为执行完 Hello World 之后并没有任何语句，程序的生命周期结束了，好了不要纠结这么多的了，只要知道这段代码会输出一段文字到屏幕上就可以了，让我们来引入问题，虽然只是短短的几行代码，但是有几个问题应该值得思考。 1.将字符输出到屏幕，需要调用 Console.WriteLine()方法。这个 Console 类型从何而来呢？ 2.如果创建一个 VB.NET 类型的项目，实现和上面 C#项目完全一样的功能，那么编译后生成的文件有什么区别？ 3.生成的文件在系统中是如何运行起来的？ 4.其机制和使用传统 VC++生成的可执行文件是否相同？ 有了这些问题，我们就可以开扯了。 2. CIL - 公共中间语言Common Intermediate Language 首先要了解的就是 C#程序源码在编译之后会得到什么样的一个文件，过去使用 VC++生成的可执行文件，经过预编译、编译、汇编、链接几个步骤后，最终生成的可执行文件中就已经包含了处理器的本地代码（Native Code），支持它运行的只是操作系统和本地的机器指令集。那么采用 C#编译器生成的文件又是什么呢？现在需要引入程序集这个概念：在.NET 框架下，类似 C#这样的高级语言经过编译后生成的结果文件被称做程序集，其后缀名是.dll（类库）或.exe（可执行程序）。在引入这个概念之前，都是用文件这个词来描述的。 我们使用IL DASM打开序章编写的 Hello World EXE 程序（不知道 IL DASM 在哪里的同学可以在一下目录找到，VS 版本不同，目录不同） ‪C:\\Program Files (x86)\\Microsoft SDKs\\Windows\\v10.0A\\bin\\NETFX 4.8 Tools\\ildasm.exe 打开 Main:void(string []) 会看到如图所示的类似汇编语言的代码，还会看到熟悉的“Hello World”，我们先不着急解释。 继续开始下一个步骤，我们用 Visual Studio 创建一个 VB.NET 程序，输入 VB 代码 12345Module Module1 Sub Main() Console.WriteLine(&quot;Hello World&quot;) End SubEnd Module 用 IL DASM 打开 Module –&gt; Main:void() 可以看到 IL 反编译 VB EXE 出来的代码与上面 C# .NET 创建的应用程序的代码几乎是一摸一样的，除了主应用程序函数入口不同。 至此，可以得到一个初步的推断：不管是 VB.NET 还是是 C#，编译之后的程序集都能够用 IL DASM 打开，因此它们生成的程序集的格式都是相同的；当程序所实现的功能相同时，程序集所包含的 CIL 代码也是类似的。 现在对上面程序集中所包含的类似汇编的语言做一下介绍，即是本节标题中的 CIL（Common Intermediate Language，公共中间语言）。CIL 最初是随着.NET 由微软一起发布的，因此之前也叫做 MSIL（Microsoft Intermediate Language），后来进行了标准化，之后便被称做 CIL。在一些书或文章中，CIL也会简写为IL，其实都是指同样的东西。为了避免混淆，本书统一用CIL这个缩写。 接下来再深入地分析一下，公共中间语言这个术语到底包含了哪几层含义。 公共因为不论是 C#语言也好，VB.NET 语言也好，C++/CLI 语言也好，甚至是重新开发的一套以自己的名字缩写命名的语言，只要它期望运行的目标平台是.NET，在经过相应的编译器编译之后，所生成的程序集就是由 CIL 语言代码描述的。 中间这个词也是大有深意，为什么不叫公共机器语言（Common Machine Language），或者公共本地语言（Common Native Language）？因为这种语言只是比我们使用的高级语言，比如 C#低级一点，并不是 CPU 可以直接执行的本地机器语言。这种语言还需要.NET 运行时（.Net runtime）环境的支持，在执行之前，进行一个被称为 Just-in-time（即时）的二次编译过程，才能转变成计算机可以识别的指令。关于.NET 运行时，以及详细过程后面再介绍，现在只要知道，这个文件所包含的 CIL 代码并非机器可以直接执行的指令代码。 语言CIL 不过是一种程序语言，只不过相对于 C#来说，它是一种更低级语言。从上面的代码截图中，已经可以看到，CIL 是一种基于堆栈的语言，同时，它提供了 class、interface、继承、多态等诸多面向对象的语言特性，因此它又是完全面向对象的语言。如果愿意，甚至可以直接编写 CIL 代码，并且使用 CIL 的编译工具 IL ASM（IL Assembler，IL 汇编程序）来对它进行编译。只不过，和大多数低级语言一样，这种方式会使开发效率会变得很低。这里注意区别一下 IL ASM 和 IL DASM，它们的拼写是不同的。 为了增加大家的理解，我们尝试自己写一段 CIL 代码 吧，并且使用IL ASM工具对其进行编译，得到和前面一样的 Hello World 程序。 打开文本编辑器，输入以下代码，然后将其保存为 HelloWorld.il 123456789101112131415.assembly extern mscorlib{}.assembly ConsoleApp{}.module ConsoleApp.exe.class public auto ansi Program extends System.Object{ .method public static void Main() { .entrypoint nop ldstr &quot;Hello, World!&quot; call void [mscorlib]System.Console::WriteLine(string) nop ret }} 打开 Visual Studio 命令行工具，不知道位置的同学请到下面的目录找到（VS 版本不同，目录不同） “C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise&quot; 然后运行 1ilasm HelloWorld.il 成功后会看到 HelloWorld.exe 程序，它的执行结果和上面用 C#编写的完全一样。 由于程序集是由 CIL 语言所描述的，因此 CIL 也叫做程序集语言（Assembly Language）。又因为.NET 程序集需要由.NET 运行时加载才能运行，可以视其为由.NET 运行时进行管理的，所以 CIL 代码也叫做托管代码（Managed Code）。相对的，不需要.NET 运行时就可以执行的代码就叫做非托管代码（Unmanaged Code）。 好了，已经知道了 CIL 的存在，从现在开始，最好在头脑里建立起两个模型或两种视角：一种是基于 C#或其他高级语言的源程序的视角，一种是基于 CIL 中间语言的程序集视角。C#源程序在被编译为程序集以后，就独立于 C#，因此程序集可以由其他种类的语言所调用；同时，因为程序集并没有包含本地机器的指令，所以它与具体的机器类型也分隔开了，可以被装有.NET 框架的任何机器运行。 3. BCL - 基类库Base Class Library 再次打开前面创建的 C# Hello World 控制台项目（ConsoleApp），然后在解决方案面板下打开“References” 我们会看这些引用，在创建项目时并没有做任何额外的操作，那么这些引用显然是在创建项目时自动添加的，都是微软认为很常用的，几乎是每个项目都会使用到的，所以在创建项目时自动添加了进来，免得开发者再手动进行添加。 那么我们删除掉这些引用会发生什么呢？好的，那我们尝试一下。 可能有人会认为，在删掉这些引用之后，编译器将会毫不客气地提示编译错误：未能找到类型或命名空间“System”（是否缺少 using 指令或程序集引用？）。可实际上，当编译并运行上面的代码时，程序会正确无误地执行。这是因为我们已经删掉了所有引用的程序集，只定义了一个 Program 类型，并没有定义 Console 类型，所以此时要面对的第一个问题就是：Console 类型从哪里来？ Visual Studio 提供了一个快捷的办法使我们可以快速查看类型：将光标定位在 Console 上，然后按下键盘上的 F12，就可以看到 Console 的类型定义。在 Console 类型定义的最上方，可以看到它所在的程序集地址: C:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework.NETFramework\\v4.7.2\\mscorlib.dll 可以看到 Console 类型来自于 mscorlib.dll 这个程序集。从上面的实验可以看出，不管我们是否引用 mscorlib.dll 程序集，它总是会自动引用进来。这个程序集中所包含的类库，即是本节标题中的BCL（Base Class Library，基类库）。从名字就可以看出来，这个类库包含的都是些最基本的类型，其本身已经与 CIL 语言融为一提了，为 CIL 语言提供基础的编程支持，以至于该类库已经成为了 CLI 标准的一部分（后面会介绍，因此也可以说 BCL 中的类型就是 CIL 语言的类型，所有面向 CIL 的语言都能够使用它们。我们可以使用对象浏览器（Visual Studio→View→Object Browser）来查看 mscorlib.dll 程序集中都包含了哪些命名空间和类型 我们继续看到 Hello World 项目引用的 System(前面删掉了，请大家重新引用回来)，我们也用对象浏览器看看它里头有什么 看到以后发现其中所包含的内容类型与 mscorlib 中的类型十分相似,这又是怎么回事呢？实际上，只要点开 System 命名空间就会发现，mscorlib.dll 的 System 命名空间下面定义的类型和 System.dll 的 System 命名空间下面定义的类型完全不同，它们之间并没有冲突之处。 现在就明白了：BCL 提供了像 Console 这样的类型来支持开发者编写类似控制台这样的程序。 既然已经思考了这么多，不妨再深入一下，思考这样一个问题：写下的这条语句 string text = “hello, world !”，其中的 string 从哪里来？从直觉来看，string 在 Visual Studio 中以深蓝色呈现，属于 C#的关键字，那么它应该是 C#提供的内置类型。可是，当我们将光标移动到 string 上并按下 F12 时，转到 string 的定义时，看到的却是下面这样的内容： 注意最上方的程序集地址，再次看到了 mscorlib.dll，并且 String 类型与 Console 类型一样，同位于 System 命名空间下。由此可见，C#的关键字 string，不过是BCL中 System.String 类型的一个别名而已。类似地，VB.NET 中的 String 关键字也是 BCL 中的 System.String 类型的别名。因此，在.NET 框架中，语言从本质上来说没有太大的区别，更多的区别是在语法方面。从上面的例子也可以看出，C#和 VB.NET 的很多语言能力并不是自己的，而是从 CIL“借”过来的这样做也保证了在不同语言中相应类型的行为是一致的。 我深入探究了一下，不同语言和 CIL 类型的对应关系，我这里列出几个，大家可以看一下： CIL C# VB.NET System.Byte byte Byte Sytem.Int16 short Short System.Int64 long Long 从上面的表看到了几种对应关系，NET 同时也对语言开发者提供支持.如你需要设计一款语言，那么在开发编译器时将语言的关键字映射为 CIL 中的类型就可以了，也就是说，对自己语言中的一些特殊符号（关键字）进行映射处理，就好像 C#中的关键字 int 和 string 一样。 大家可能听说过这样一种特殊的类型——基元类型(Primitive Type)。实际上，讲到这里大家应该已经明白了，那些由编译器直接支持，将语言本身的关键字类型转换为 CIL 类型的，就叫做基元类型。显然，上面的 byte、int、string 都是基元类型。而 C#中并没有一个关键字去映射 Console，所以我们认为 Console 只是普通的类类型（Class Type）。 4. FCL - 框架类库Framework Class Library 作为一名.NET 程序员，每天都要打交道的就是 FCL 了（Framework Class Library，框架类库）。在上一节中介绍了 BCL，它是 FCL 的一个子集。BCL 中包含了与编译器及 CIL 语言关系紧密的核心类型，以及常见开发任务中都会使用到的类型。而 FCL 包含的内容极多。 从功能上来看，可以将 FCL 框架类库划分成以下几层。 最内一层由 BCL 的大部分组成，主要作用是对.NET 框架、.NET 运行时及 CIL 语言本身进行支持，例如基元类型、集合类型、线程处理、应用程序域、运行时、安全性、互操作等。 中间一层包含了对操作系统功能的封装，例如文件系统、网络连接、图形图像、XML 操作等。 最外一层包含各种类型的应用程序，例如 WinForms、Asp.NET、WPF、WCF、WF、UWP 等。 5. CTS - 公共类型系统Common Type System 假设要开发一套新的语言，这种语言和 C#或 VB.NET 一样，在编译后也能够生成 CIL 代码，也可以在.NET 环境下运行，那么首先需要什么呢？ 根据 3 中所讲述的内容知道，要开发的新语言相当于 CIL 的高级语言版本，所以实际上要做什么并不是由新语言决定的，而是由 CIL 来决定的。因此，需要一套 CIL 的定义、规则或标准。这套规则定义了我们的语言可以做什么，不可以做什么，具有哪些特性。这套规则就称作 CTS（Common Type System，公共类型系统）。任何满足了这套规则的高级语言就可以称为面向.NET 框架的语言。C#和 VB.NET 不过是微软自己开发的一套符合了 CTS 的语言，实际上还有很多的组织或团体，也开发出了这样的语言，比如 Delphi.Net、FORTRAN 等。 那么 CTS 具体包括哪些内容呢？在回答这个问题之前我们需要弄清楚一个概念。还是通过一段 C#代码来说明，先看下面几行代码： 1234public class Zonx {}Zonx item1 = new Zonx();Zonx item2 = new Zonx(); 我们用文字描述上面的代码，可以说 Zonx 是类类型（class type），item1，item2 都是这个类的实例（example）。 类似的，还有枚举类型（Enum Type）、结构类型（(Struct Type）等。现在大家应该明白这里要表达的意思了，CTS 规定了可以在语言中定义诸如类、结构、委托等类型，这些规则定义了语言中更高层次的内容。因此，在 C#这个具体的语言实现中，我们才可以去定义类类型（Class Type）或者结构类型（Struct Type）等。 同样，可以在 Book 类中定义一个字段 name 并提供一个方法 ShowName()。实际上，这些也是 CTS 定义的，它规范了类型中可以包含字段（filed）、属性（property）、方法（method）、事件（event）等。 除了定义各种类型外，CTS 还规定了各种访问性，比如 Private、Public、Family（C#中为 Protected）、Assembly(C#中为 internal)、Family and assembly(C#中没有提供实现)、Family or assembly(C#中为 protected internal)。 CTS 还定义了一些约束，例如，所有类型都隐式地继承自 System.Object 类型，所有类型都只能继承自一个基类。从 CTS 的名称和公共类型系统可以看出，不仅 C#语言要满足这些约束，所有面向.NET 的语言都需要满足这些约束。众所周知，传统 C++是可以继承自多个基类的。为了让熟悉 C++语言的开发者也能在.NET 框架上开发应用程序，微软推出了面向.NET 的 C++/CLI 语言（也叫托管 C++），它就是符合 CTS 的 C++改版语言，为了满足 CTS 规范，它被限制为了只能继承自一个基类。 关于上面内容有两点需要特别说明： C#并没有提供 Family and assembly 的实现，C#中也没有全局方法(Global Method)。换言之，C#只实现了 CTS 的一部分功能。，也就是说，CTS 规范了语言能够实现的所有能力，但是符合 CTS 规范的具体语言实现不一定要实现 CTS 规范所定义的全部功能。 C++/CLI 又被约束为只能继承自一个基类，换言之，C++中的部分功能被删除了。任何语言要符合 CTS，其中与 CTS 不兼容的部分功能都要被舍弃。 显然，由于 CIL 是.NET 运行时所能理解的语言，因此它实现了 CTS 的全部功能。虽然它是一种低级语言，但是实际上，它所具有的功能更加完整。C#语言和 CIL 的关系，可以用下图表示： 6. CLS - 公共语言规范Common Language Specification 既然已经理解了 CTS 是一套语言的规则定义，就可以开发一套语言来符合 CTS 了。假设这个语言叫做 N#，它所实现的 CTS 非常有限，仅实现了其中很少的一部分功能，它与 CTS 和 C#语言的关系可能如图 那么现在就有一个问题：由 C#编写的程序集，能够引用由 N#编写的程序集吗？答案显然是不能，，虽然 C#和 N#同属于 CTS 旗下，但是它们并没有共通之处。因此，虽然单独的 N#或 C#程序可以完美地在.NET 框架下运行，但是它们之间却无法相互引用。如果使用 N#开发项目的开发者本来就不希望其他语言类型的项目来引用他的项目倒也罢了，但是，如果 N#项目期望其他语言类型的项目能够对它进行引用，就需要 N#中公开的类型和功能满足 C#语言的特性，即它们需要有共通之处。注意，这句话中有一个词很重要，就是“公开的”（public）。N#中不公开的部分（private、internal、protected）是不受影响的，可以使用独有的语言特性，因为这些不公开的部分本来就不允许外部进行访问。因此， 如果 N#想要被 C#所理解和引用，它公开的部分就要满足 C#的一些规范，此时，它与 CTS 和 C#语言的关系就会变成如图 如果世界上仅有 C#和 N#两种语言就好办了，把它们共同的语言特性提取出来，然后要求所有公开的类型都满足这些语言特性，这样 C#和 N#程序集就可以相互引用了。可问题是：语言类型有上百种之多，并且.NET 的设计目标是实现一个开放的平台，不仅现有的语言经过简单修改就可以运行在.NET 框架上，后续开发的新语言也可以，而新语言此时并不存在，如何提取出它的语言特性？因此又需要一套规范和标准来定义一些常见的、大多数语言都共有的语言特性。对于未来的新语言，只要它公开的部分能够满足这些规范，就能够被其他语言的程序集所使用。这个规范就叫做 CLS （Common Language Specification，公共语言规范）。很明显，CLS 是 CTS 的一个子集。现在引入了 CLS 如果利用 C#开发的一个程序集的公开部分仅采用了 CLS 中的特性，那么这个程序集就叫做 CLS 兼容程序集（CLScompliant assembly）。显然，对于上面提到的 FCL 框架类库，其中的类型都符合 CLS，仅有极个别类型的成员不符合 CLS，这就保证了所有面向.NET 的语言都可以使用框架类库中的类型。 上面几段文字中反复出现了一个词———“语言特性”（language features），满足 CLS 就是要求语言特性要一致，那么什么叫做语言特性？这里给出几个具体的语言特性：是否区分大小写，标识符的命名规则如何，可以使用的基本类型有哪些，构造函数的调用方式（是否会调用基类构造函数），支持的访问修饰符等。 那么我们如何检验程序集是否符合 CLS 呢？.NET 为我们提供了一个特性 CLSCompliant，便于在编译时检查程序集是否符合 CLS。我创建了一个类，我们来看下面一个例子： 编译器报出警告 CS3005:仅大小写不同的标识符“CLSTest.Name()”不符合 CLS CS3002:“CLSTest.GetValue()”的返回类型不符合 CLS CS3001:参数类型“sbyte”不符合 CLS CS3008:标识符“CLSTest._aFiled”不符合 CLS 编译器给出的只是警告信息，而非错误信息，因此可以无视编译器的警告，不过这个程序集只能由其他 C#语言编写的程序集所使用 7. CLR - 公共语言运行时Common Language Runtime 程序集包含了 CIL 语言代码，而 CIL 语言代码是无法直接运行的，需要经过.NET 运行时进行即时编译才能转换为计算机可以直接执行的机器指令。那么这个过程是如何进行的呢？ 接下来我们要了解的就是.NET 框架的核心部分：CLR（Common Language Runtime），公共语言运行时），有时也会称做.NET 运行时（.NET runtime）。在了解 CLR 之前，需要先进一步学习一下程序集，因为下一节会对程序集进行专门的讲述，这里仅简单介绍一下程序集中对于理解 CLR 有帮助的概念。 从直觉上来看，前面以.exe 为后缀的控制台应用程序就是一个直接的可执行文件，因为在双击它后，它确实会运行起来。这里的情况和面向对象中的继承有一点像：一台轿车首先是一部机动车、一只猫首先是一个动物，而一个.NET 程序集首先是一个 Windows 可执行程序。 那么什么样格式的文件才是一个 Windows 可执行文件？这个格式被称做 PE/COFF（Microsoft Windows Portable Executable/Common Object File Format），Windows 可移植可执行/通用对象文件格式。Windows 操作系统能够加载并运行.dll 和.exe 是因为它能够理解 PE/COFF 文件的格式。显然，所有在 Windows 操作系统上运行的程序都需要符合这个格式，当然也包括.NET 程序集在内。在这一级，程序的控制权还属于操作系统，PE/COFF 头包含了供操作系统查看和利用的信息。此时，程序集可以表示成如图 在前面提到过，程序集中包含的 CIL 语言代码并不是计算机可以直接执行的，还需要进行即时编译，那么在对 CIL 语言代码进行编译前，需要先将编译的环境运行起来，因此 PE/COFF 头之后的就是 CLR 头了。CLR 头最重要的作用之一就是告诉操作系统这个 PE/COFF 文件是一个.NET 程序集，区别于其他类型的可执行程序。 在 CLR 头之后就是大家相对熟悉一些的内容了。首先，程序集包含一个清单（manifest），这个清单相当于一个目录，描述了程序集本身的信息，例如程序集标识（名称、版本、文化）、程序集包含的资源（Resources）、组成程序集的文件等。 清单之后就是元数据了。如果说清单描述了程序集自身的信息，那么元数据则描述了程序集所包含的内容。这些内容包括：程序集包含的模块（会在第 7 章介绍）、类型、类型的成员、类型和类型成员的可见性等。注意，元数据并不包含类型的实现，有点类似于 C++中的.h 头文件。在.NET 中，查看元数据的过程就叫做反射（Reflection） 接下来就是已经转换为 CIL 的程序代码了，也就是元数据中类型的实现，包括方法体、字段等，类似于 C++中的.cpp 文件。 图中还多添加了一个资源文件，例如.jpg 图片。从这幅图可以看出，程序集是自解释型的（Self-Description），不再需要任何额外的东西，例如注册表，就可以完整地知道程序集的一切信息。 现在已经了解过了程序集，并且知道程序集中包含的 CIL 代码并不能直接运行，还需要 CLR 的支持。概括来说，CLR 是一个软件层或代理，它管理了.NET 程序集的执行，主要包括：管理应用程序域、加载和运行程序集、安全检查、将 CIL 代码即时编译为机器代码、异常处理、对象析构和垃圾回收等。相对于编译时（Compile time），这些过程发生在程序运行的过程中，因此，将这个软件层命名为了运行时，实际上它本身与时间是没有太大关系的。有一些朋友在初学.NET 的时候，纠结在了 Runtime 这个词上，总以为和时间有什么关系，总是不能很好地理解 CLR。笔者认为重要的是理解 CLR 是做什么的，而不用过于关注它的名称。 实际上，CLR 还有一种叫法，即 VES（Virtual Execution System，虚拟执行系统）。从上一段的说明来看，这个命名应该更能描述 CLR 的作用，也不容易引起混淆，但是可能为了和 CIL、CTS、CLS 等术语保持一致性，最后将其命名为了 CLR。在这里，我们知道 CLR 不过是一个.NET 程序集的运行环境而已，有点类似于 Java 虚拟机。VES 这个术语来自于 CLI 前面已经概要地了解了 CLR 的作用，接下来开始更进一步的学习。首先遇到的问题就是：CLR 以什么样的形式位于什么位置？ 由于 CLR 本身用于管理托管代码，因此它是由非托管代码编写的，并不是一个包含了托管代码的程序集，也不能使用 IL DASM 进行查看。它位于 C:%SystemRoot%\\Microsoft.NET\\Framework\\版本号下，视安装的机器不同有两个版本，一个是工作站版本的 mscorwks.dll，一个是服务器版本的 mscorsvr.dll。wks 和 svr 分别代表 work station 和 server。 接下来再看一下 CLR 是如何运行起来的。虽然从 Windows Server 2003 开始，.NET 框架已经预装在操作系统中，但是它还没有集成为操作系统的一部分。当操作系统尝试打开一个托管程序集（.exe）时，它首先会检查 PE 头，根据 PE 头来创建合适的进程。 接下来会进一步检查是否存在 CLR 头，如果存在，就会立即载入 MsCorEE.dll。这个库文件是.NET 框架的核心组件之一，注意它也不是一个程序集。MsCorEE.dll 位于 C:%SystemRoot%\\System32\\系统文件夹下所有安装了.NET 框架的计算机都会有这个文件。大家可能注意到了，这个库安装在 System32 系统文件夹下，而没有像其他的核心组件或类库那样按照版本号存放在 C:%SystemRoot%\\Microsoft.NET\\Framework\\文件夹下。这里又存在一个“鸡生蛋问题”：根据不同的程序集信息会加载不同版本的 CLR，因此加载 CLR 的组件就应该只有一个，不能再根据 CLR 的版本去决定加载 CLR 的组件的版本。 MsCorEE.dll 是一个很细的软件层。加载了 MsCorEE.dll 之后，会调用其中的_CorExeMain()函数，该函数会加载合适版本的 CLR。在 CLR 运行之后，程序的执行权就交给了 CLR。CLR 会找到程序的入口点，通常是 Main()方法，然后执行它。这里又包含了以下过程： 加载类型。在执行 Main()方法之前，首先要找到拥有 Main()方法的类型并且加载这个类型。CLR 中一个名为 Class loader（类加载程序）的组件负责这项工作。它会从 GAC、配置文件、程序集元数据中寻找这个类型，然后将它的类型信息加载到内存中的数据结构中。在 Class loader 找到并加载完这个类型之后，它的类型信息会被缓存起来，这样就无需再次进行相同的过程。在加载这个类以后，还会为它的每个方法插入一个存根（stub）。验证。在 CLR 中，还存在一个验证程序（verifier），该验证程序的工作是在运行时确保代码是类型安全的。它主要校验两个方面，一个是元数据是正确的，一个是 CIL 代码必须是类型安全的，类型的签名必须正确。即时编译。这一步就是将托管的 CIL 代码编译为可以执行的机器代码的过程，由 CLR 的即时编译器（JIT Complier）完成。即时编译只有在方法的第一次调用时发生。回想一下，类型加载程序会为每个方法插入一个存根。在调用方法时，CLR 会检查方法的存根，如果存根为空，则执行 JIT 编译过程，并将该方法被编译后的本地机器代码地址写入到方法存根中。当第二次对同一方法进行调用时，会再次检查这个存根，如果发现其保存了本地机器代码的地址，则直接跳转到本地机器代码进行执行，无需再次进行 JIT 编译。可以看出，采用这种架构的一个好处就是，.NET 程序集可以运行在任何平台上，不管是 Windows、UNIX，还是其他操作系统，只要这个平台拥有针对于该操作系统的.NET 框架就可以运行.NET 程序集。 8. CLI - 公共语言基础Common Language Infrastructure CLI 是一个国际标准，由 ECMA 和 ISO 进行了标准化，全称为 Common Language Infrastructure（公共语言基础）。它只是一个概念和汇总，实际上本章的每一小节都是这个标准的一部分。CLI 包括：CIL、CTS、CLS、VES、元数据、基础框架。 看到这里很多人会感觉到有点奇怪，为什么 CLI 和.NET 框架包含的内容如此雷同？它们之间是什么关系？简单来说，CLI 是一个标准，而.NET 框架是这个标准的具体实现。在 CLI 中，并没有 CLR 的概念，只有 VES，而 CLR 就是.NET 框架中 VES 的具体实现。既然 CLI 只是一个标准，而.NET 框架是它在 Windows 平台上的具体实现，那么是不是就只有.NET 框架这一个 CLI 的实现？显然不是，Mono Project 就是 CLI 标准的另一个实现。Mono Project 的目标就是将.NET 框架多平台化，使其可以运行在各种平台上，包括 Mac OS、Linux 等。 CLI 的详细信息可以在这里查看. 9. 终章把上面的知识巩固一下，到底什么是.NET 框架这个问题应该有了答案，对常见的所有术语，例如程序集、CIL、CTS、CLS、CLR 等，大家会对.NET 框架有一个更好的全局性认识。","link":"/2020/01/07/dotnet_framework/"},{"title":".NET Core With gRpc","text":"gRpc 是 Google 开源的一个与语言无关的高性能远程过程调用 (RPC) 框架，RPC（Remote Procedure Call Protocol）远程过程调用协议。一个通俗的描述是：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样。 在 gRpc 里，客户端可以直接调用不同机器上的服务应用的方法，就像是本地对象一样，所以创建分布式应用和服务就很简单了。在很多 RPC(Remote Procedure Call Protocol)系统里，gRpc 是基于定义一个服务，指定一个可以远程调用的带有参数和返回类型的的方法。在服务端，服务实现这个接口并且运行 gRpc 服务处理客户端调用。 Google ProtobufgRpc 使用协议缓冲作为传输格式，gRpc 使用Google Protobuf,使用协议缓冲的第一步是在 proto file 里为数据定义你想序列化的结构：可以是普通的.proto 扩展的文本文件。协议缓冲数据结构为 messages，每条 message 是一个小的逻辑记录的信息包含一些 name-value 对名为 fields，比如： 12345message Person { string name = 1; int32 id = 2; bool has_ponycopter = 3;} 然后，一旦你指定了你的数据结构，使用协议缓冲解析器 protoc 生成数据访问类在 proto 定义的语言。这些为每个字段(比如 name()和 set_name())和方法序列化/解析整个结构到/从 raw bytes 提供了简单的访问器 - 比如，你选择的语言是 C++，对上面的例子运行编译会生成一个 Person 类。然后就可以在应用里使用这个类去 populate，序列化和获取 Person 协议缓冲 messages。 gRpc Service接下来我们就开始编写我们的第一个 gprc 服务，然后演示调用，首先准便好 .NET Core With gRpc 的开发环境，我们这里使用 VS2019 创建模板，需要在安装的时候勾选如下 Workloads: 创建项目成功以后，会自动生成 Protos 文件夹，里头会有一个默认的 protobuf 文件 -&gt; greet.proto，并且已经定义了一个 request data 和 response data 以及一个 service。 123456789101112131415syntax = &quot;proto3&quot;;option csharp_namespace = &quot;gRpcService&quot;;package greet;service Greeter { rpc SayHello (HelloRequest) returns (HelloReply);}message HelloRequest { string name = 1;}message HelloReply { string message = 1;} 模板也为我们创建相应的服务文件 -&gt; GreeterService.cs，我们打开这个文件，然后对我们在 protobuf 文件中定义的服务进行实现，实现 SayHello 方法。 1234567public override Task&lt;HelloReply&gt; SayHello(HelloRequest request, ServerCallContext context){ return Task.FromResult(new HelloReply { Message = &quot;Hello &quot; + request.Name });} 短短的几行代码我就已经实现了一个最简陋的 gRpc 服务，我们来看一下我们做了什么，我们定义了一个 request data -&gt; HelloRequest，这用于我们发送请求的时候提交一些我们自己的数据，然后我们定义了一个 response data -&gt; HelloReply，这用于响应我们请求的同时返回一些数据，然后我们定义了一个 gRpc service -&gt; SayHello， 这定义了这个请求应该如何接收参数以及返回数据。 我们使用 dotnet run 命令，进行编译以及启动。 这样我们的 gRpc 服务就已经跑起来了，大家也可以在 launchSettings.json 中配置启动的端口以及域名。 gRpc Client我们现在实现一个客户端去调用我们的 gRpc 服务，在当前解决方案中添加一个 .NET Core Console 项目，然后在 Dependencies 上面右键点击 Add Connected Service ，然后添加一个 gRpc 服务，如图所示。 然后等待 VS 分析以及校验完，如果没有问题的话，就会显示成功，并且会将这个 proto 文件拷贝一份到当前项目的 Protos 文件夹下： 然后我们发送我们的第一个 gRpc 服务器调用，我们就直接写到主函数了： 1234567891011121314151617181920212223using Grpc.Net.Client;using GrpcService;using System;using System.Net.Http;namespace GrpcClient{ class Program { static async System.Threading.Tasks.Task Main(string[] args) { var httpHandler = new HttpClientHandler(); httpHandler.ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator; var channel = GrpcChannel.ForAddress(&quot;https://localhost:5001&quot;, new GrpcChannelOptions { HttpHandler = httpHandler }); var client = new Greeter.GreeterClient(channel); var response = await client.SayHelloAsync(new HelloRequest { Name = &quot;lingme&quot; }); Console.WriteLine(response.Message); } }} 如果出现某个类型缺失引用，我们可以使用 VS 的智能快捷键 Alt + Enter 实现快速 Nuget 安装和引用，上面的代码过于简单我就不一一解释了，我们运行起我们的服务端和客户端，就会看到如下结果，我们的教程至此结束，一个简单的 grpc 服务和客户端就这样实现了，大家可以举一反三应用到自己的实际项目中，比如我正在做的 IM 聊天软件项目。","link":"/2020/11/08/dotnet_grpc/"},{"title":"Hi, WebAssembly","text":"说到前端，大家脑海中的飞过的第一个概念肯定是 Javascript + CSS + HTML，从 1995 诞生之初到现在，可以说是长盛不衰，一直位居最火编程语言之一的宝座，也是从那个时候到如今这么多年的发展，前端的语言基础基本确立，就是上面说的三剑客。很多浏览器加入了即时编译器，又称之为 JITs。在这种模式下，JavaScript 在运行的时候，JIT 选择模式然后基于这些模式使代码运行更快。这些 JITs 的引入是浏览器运行代码机制的一个转折点。所有的突然之间，JavaScript 的运行速度快了 10 倍。 发展随着这种改进的性能，JavaScript 开始被用于意想不到的事情，比如依靠强大的 NodeJS 平台， JS 开始像病毒一样蔓延各个领域， WebService，WebAPI，CI/CD，结合 Electron 模块， 甚至在桌面开发都占有了一丝地位…..，虽然 JS 过于强大，但是随着 Web 应用的需求和野性日益膨胀，JS 也开始暴漏了诸多问题，暂时不说混乱的隐式类型转换之类的问题，最大的问题在于性能瓶颈，前端的开发逻辑越来越复杂，相应的代码量随之变的越来越多。相应的，整个项目的起步的时间越来越长。在性能不好的电脑上，启动一个前端的项目甚至要花上十多秒。 除了逻辑复杂、代码量大，还有另一个原因是 JavaScript 这门语言本身的缺陷，JavaScript 没有静态变量类型。这门解释型编程语言的作者 Brendan Eich，仓促的创造了这门如果被广泛使用的语言，以至于 JavaScript 的发展史甚至在某种层面上变成了填坑史。为什么说没有静态类型会降低效率。这会涉及到一些 JavaScript 引擎的一些知识。 JavaScript 执行过程 我们来看一看 JavaScript 代码在引擎中会经历什么。 1.JavaScript 文件被下载到客户端。 2.进入 Parser，Parser 会把代码转化成 AST（抽象语法树）. 3.然后根据抽象语法树，Bytecode Compiler 字节码编译器会生成引擎能够直接阅读、执行的字节码。 4.字节码进入翻译器，将字节码一行一行的翻译成效率十分高的 Machine Code. 在项目运行的过程中，引擎会对执行次数较多的 function 记性优化，引擎将其代码编译成 Machine Code 后打包送到顶部的 Just-In-Time(JIT) Compiler，下次再执行这个 function，就会直接执行编译好的 Machine Code。但是由于 JavaScript 的动态变量，上一秒可能是 Array，下一秒就变成了 Object。那么上一次引擎所做的优化，就失去了作用，此时又要再一次进行优化。 WebAssembly 诞生所以在 2015 年，我们迎来了 WebAssembly。WebAssembly 是经过编译器编译之后的代码，体积小、起步快。在语法上完全脱离 JavaScript，同时具有沙盒化的执行环境。WebAssembly 同样的强制静态类型，是 C/C++/Rust 的编译目标。 那大家可能会说，为什么我几乎没有听过 WebAssembly 这项技术的实际应用，其实最早用于实际产品的是谷歌，谷歌在谷歌地球中频繁使用这项技术来提高 3D 渲染性能。 WebAssembly 会替代 JS？不会，WebAssembly 是被设计成 JavaScript 的一个完善、补充，而不是一个替代品。WebAssembly 将很多编程语言带到了 Web 中。但是 JavaScript 因其不可思议的能力，仍然会在很多年之后保持霸主地位。 何时使用？我们应该在什么时候使用 WebAssembly？ 1.对性能有很高要求的 App/Module/游戏 2.在 Web 中使用 C/C++/Rust/Go 的库 第一个 WebAssembly 示例说了那么多，我们还是依照程序员的惯例 “show code”，我们自己写一个 WebAssembly 示例，来熟悉一下大致的流程和如何实际应用。 开发工具准备 AssemblyScript 支持直接将 TypeScript 编译成 WebAssembly。 Emscripten 可以说是 WebAssembly 的灵魂工具不为过，上面说了很多编译，这个就是那个编译器。将其他的高级语言，编译成 WebAssembly。 WABT 是个将 WebAssembly 在字节码和文本格式相互转换的一个工具，方便开发者去理解这个 wasm 到底是在做什么事。 WebAssembly Studio 在线的 WebAssembly 编译工具，可以方便的把我们的代码编译成 wasm 模块文件。 C++代码编写打开 WebAssembly Studio，创建一个空 C 项目，国际惯例返回 Hello World，以及两个数相加。 输入代码： 1234567891011121314151617181920#define WASM_EXPORT __attribute__((visibility(&quot;default&quot;)))#include &lt;stdio.h&gt;WASM_EXPORTint main(){ return 0;}WASM_EXPORTint sum(int a, int b){ return a+b;}WASM_EXPORTchar * c_hello(){ return &quot;Hello World&quot;;} 点击 Build，将会生成一个 wasm 文件，然后右键下载下来，创建一个 html 文件，输入以下代码 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;Say Hi from WebAssembly&lt;/h2&gt; &lt;span id=&quot;hi_container&quot;&gt;&lt;/span&gt; &lt;h2&gt;Sum two numbers from WebAssembly&lt;/h2&gt; &lt;span id=&quot;sum_container&quot;&gt;&lt;/span&gt; &lt;script&gt; fetch('main.wasm') .then((bytes) =&gt; bytes.arrayBuffer()) .then((mod) =&gt; WebAssembly.compile(mod)) .then((module) =&gt; { return new WebAssembly.Instance(module); }) .then((instance) =&gt; { let buffer = new Uint8Array(instance.exports.memory.buffer); let test = instance.exports.c_hello(); let mytext = ''; for (let i = test; buffer[i]; i++) { mytext += String.fromCharCode(buffer[i]); } document.getElementById('hi_container').textContent = mytext; document.getElementById('sum_container').textContent = instance.exports.sum(100 + 300); }); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 运行起来查看效果","link":"/2020/11/07/firstwebassembly/"},{"title":"Github Action 自动部署Hexo","text":"我个人搭建博客已经有走过了很长的一段路程了，从之前的博客园 -&gt; WordPress -&gt; 自主建站 -&gt; 到现在的 Github Page，从原来的喜欢折腾，到现在的不想做任何维护，心态也发生了很大的变化，现在只想找一个什么都不管，就专心写博文的平台，在 17 年接触到了 Hexo，那个时候发现这个 nodejs 实现的博客框架真的很不错，生成页面的速度很快，也提供了 ejs 构建自己的渲染主题，而且搭配 github page，让我感受到了前所未有的清爽，轻量，迅速，现代化的 UI，各种插件（评论插件，访问量插件，随便举几个例子），一瞬间就俘获了我，但是每次都得 generate 和 deploy 太麻烦了，于是在 github action 推出的时候，我也第一时间把这些繁琐的事情 CI/CD 化了，接下来就介绍一下如何配合 github action 实现懒人之道。 1.项目背景 项目 介绍 可见性 lingme.github.io github page 仓库，用于存放 hexo 生成的静态站点文件 public lingme.github.io.repository hexo 源文件仓库 private 2.部署密钥生成hexo 编译后需要 push 到 lingme.github.io 上，需要用 ssh-keygen 命令生成一组私钥（没有后缀名）和公钥（.pub 结尾） 我们打开终端，输入 ssh 命令生成一组密钥 ssh-keygen -f github-deploy-key 打开 lingme.github.io 仓库,点击 setting / deploy key ，然后点击 add new key，使用 pbcopy &lt; github-deploy-key.pub 命令将 key value 拷贝到剪切板，然后复制到 add new key 的输入框中，名称可以填写 HEXO_DEPLOY_PUB ,记住一定要勾选 allow write 打开 lingme.github.io.repository 仓库，点击 setting / secrets / add new key，使用 pbcopy &lt; github-deploy-key 命令将 key value 拷贝到剪切板，然后复制到输入框中，名称可以取名为 HEXO_DEPLOY_PRI 3.创建 github action workflow点击 lingme.github.io.repository 的 action 按钮，然后输入如下内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344name: HEXO CIon: [push]jobs: build: runs-on: ubuntu-latest strategy: matrix: node-version: [10.x] steps: - uses: actions/checkout@v1 - name: Use Node.js ${{ matrix.node-version }} uses: actions/setup-node@v1 with: node-version: ${{ matrix.node-version }} - name: Configuration environment env: HEXO_DEPLOY_PRI: ${{secrets.HEXO_DEPLOY_PRI}} run: | mkdir -p ~/.ssh/ echo &quot;$HEXO_DEPLOY_PRI&quot; &gt; ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts git config --global user.name &quot;lingme&quot; git config --global user.email &quot;kid--l@hotmail.com&quot; - name: Install dependencies run: | npm i -g hexo-cli npm install hexo-deployer-git --save npm i - name: Generate static blog file run: | hexo generate - name: Import custom extension style run: | chmod +x ./endPoint.sh ./endPoint.sh - name: Deploy to github page run: | hexo deploy 记住要在自己的 hexo _config.yml 里头配置自己的部署地址： 1234deploy: type: git repo: git@github.com:lingme/lingme.github.io.git branch: master 中间可以加一些中间过程，比如我的 workflow 步骤中有一个步骤叫做 Import custom extension style ，他会运行一个 shell 脚本，帮我做一些博客样式上面的调整，如果你绑定了域名，请把 CNAME 文件放到 hexo 源文件的 source 文件夹中，这样 generate 的时候才会一起打包。 然后可以在 source/_posts 中写一个 md 博文，并且 push 到服务器上面测试了。 我们登陆 github ，看到 action 已经在跑自动化流水线了 等一分钟左右，喝杯茶，我们发现 hexo 已经被自动化部署好了，访问一下域名看成果把","link":"/2019/12/01/github_action_automation_deploy_hexo/"},{"title":"Travis CI&#x2F;CD自动化部署Hexo","text":"由于博客的源码和生成站点位于不同的代码仓库中（源码位于 lingme.github.io.repository，生成的静态站点位于 lingme.github.io，即个人 GitHub Pages 的仓库），文章的发布过程需要提交两次。作为懒人之道，自然会开始折腾只需要提交一次、博客就自动部署到 GitHub Pages 上的方法——这里就轮到 Travis 登场了。 原理Travis 为 GitHub 上的开源项目提供免费的持续集成（CI）服务，只要你向指定仓库提交了代码，Travis 就会根据配置自动运行 CI 任务。利用这个特性，我们可以做到在一次提交过程中触发如下流程： 内容编辑完成，向博客的源码仓库 push 代码GitHub 通过 hook 告诉 Travis 有新的提交，Travis 启动新的 CI 任务在 CI 任务中，代码被 clone 到 Travis 的构建服务器上构建服务器准备好 Node.js 的运行环境，运行 Hexo 的生成命令，并将生成的静态站点 push 到 GitHub Pages 的仓库中，博客部署完成这个过程中的难点在于如何给予 Travis push 你的 GitHub Pages 仓库的权限。有两种方法可以获得 push 权限： SSH 私钥：只要在 GitHub 上配了相应公钥，就可以通过 SSH 进行 pushPersonal access token：只要在 GitHub 上生成了 personal access token，就可以通过 HTTPS 进行 push但是，无论是使用上述的哪种方法，SSH 私钥 / personal access token 都不能出现在 Travis 的配置文件里，因为 Travis 的配置文件（即 .travis.yml）会出现在博客的源码仓库里，这意味着任何能访问你提交历史的路人（对于 GitHub 的公开项目来说，意味着任何人）都能获取到它们并用来向你的仓库进行任意提交——这是灾难性的（顺带一提，GitHub 如果发现你的代码仓库中含有 personal access token，会自动删除相应 token，因此向仓库提交 personal access token 的行为并不会带来风险，只是没有意义而已，因为 token 会直接失效）。因此，我们需要使用 Travis 客户端对 SSH 私钥 / personal access token 进行加密，然后在 CI 任务中解密并使用它们。 部署密钥生成hexo 编译后需要 push 到 lingme.github.io 上，需要用 ssh-keygen 命令生成一组私钥（没有后缀名）和公钥（.pub 结尾） 我们打开终端，输入 ssh 命令生成一组密钥 ssh-keygen -f github-deploy-key 打开 lingme.github.io 仓库,点击 setting / deploy key ，然后点击 add new key，使用 pbcopy &lt; github-deploy-key.pub 命令将 key value 拷贝到剪切板，然后复制到 add new key 的输入框中，名称可以填写 HEXO_DEPLOY_PUB ,记住一定要勾选 allow write 打开 lingme.github.io.repository 仓库，点击 setting / secrets / add new key，使用 pbcopy &lt; github-deploy-key 命令将 key value 拷贝到剪切板，然后复制到输入框中，名称可以取名为 HEXO_DEPLOY_PRI 准备工作注册 Travis 并将 Github Pages 的源码项目加入 Travis 准备一个 Github 的 personal access token 安装 Travis 客户端（考虑到很多小伙伴的 VPN 比较慢，所以替换成国内缘）： 123456789101112131415# install rvmgpg --keyserver hkp://keys.gnupg.net:80 --recv-keys D39DC0E3\\curl -sSL https://get.rvm.io | bash -s stablesource /home/uchuhimo/.rvm/scripts/rvmecho &quot;ruby_url=https://cache.ruby-china.org/pub/ruby&quot; &gt; ~/.rvm/user/db# install rubyrvm install 2.4.0rvm use 2.4.0 --default# configure gemgem sources --add https://gems.ruby-china.org/ --remove http://rubygems.org/# install travisgem install travis 配置 Travis在博客的源码项目下新建 .travis.yml：touch .travis.yml 加密上文生成的 personal access token：travis encrypt GITHUB_TOKEN=”“ –add 在 .travis.yml 中添加如下内容（记得替换变量）： 12345678910111213141516171819language: node_jsnode_js: - &quot;7&quot;before_deploy: - hexo generatedeploy: provider: pages skip_cleanup: true github_token: $GITHUB_TOKEN on: branch: master repo: &lt;username&gt;/&lt;github-pages-repo-name&gt; local_dir: public target_branch: master fqdn: &lt;custom-domain-url&gt; project_name: &lt;project-name&gt; email: &lt;committer-email&gt; name: &lt;committer-name&gt; 参考文献 GitHub Pages Deployment - Travis CI Travis Github","link":"/2019/11/01/github_pages_travis/"},{"title":"OAuth 2.0","text":"现如今，微信和支付宝以一种近乎病毒式的发展速度蔓延到了互联网的每一个角落，你几乎可以在所有主流应用上面看到以微信，或者以支付宝登录的字样，这种方式就是 OAuth 授权方式，让第三方应用不会触及到用户的帐号信息（如用户名与密码），即第三方应用无需使用用户的用户名与密码就可以申请获得该用户资源的授权。 简介 OAuth 2.0 的标准是 RFC-6749，PKCE 的标准是 RFC-7636 OAuth 协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是 OAuth 的授权不会使第三方触及到用户的号信息（如用户名与密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，OAuth 是 Open Authorization 的简写。 OAuth 的核心思想就是引入了一个授权层，用来分离两种不同的角色：客户端和资源所有者。资源所有者同意以后，资源服务器可以向客户端颁发令牌。客户端通过令牌，去请求数据，过程如下： 颁发模式 在 OAuth 2.0 RFC-6749 中规定了这几种模式颁发令牌： 授权码（ Authorization Code ） Authorization Code Authorization Code With PKCE 隐含式（ Implicit ） 密码式（ Resource Owner Password Credentials ） 客户端凭证（ Client Credentials ） Legacy Device Authorization Flow 授权码 授权码（authorization code）方式，指的是第三方应用先申请一个授权码，然后再用该码获取令牌，这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏，对于 SPA （Single Page Application）应用，则还有更安全的 PKCE 模式 我们以 Vercel 认证 Github 登录为例，来说一下这个模式的流程： * ***A***. Vercel 在登录页有可以支持 Github 登录的选项，用户选择以 Github 登录 Vercel * ***B***. 开始授权： * ***1*** -&gt; 重定向到 Github 授权页面 * ***2*** -&gt; 用户点击允许 Vercel 访问我的个人数据 * ***3*** -&gt; 授权通过，返回授权码 * ***C***. 拿到授权码后，Github 认证服务器将用户导向 Vercel 事先指定的**重定向URL**（Redirection URL），同时附带上授权码 * ***D***. Vercel 收到授权码，附上之前的重定向URL，向认证服务器申请令牌，这一步在 Github 后台完成，对于用户来说是无感知的 * ***E***. 认证服务器核对了授权码和重定向URL没问题，然后给 Vercel 颁发令牌（Access Token）和更新令牌（Refresh Token） PKCE 模式 * PKCE 增强的授权码流引入了一个由调用应用程序（SPA）创建的密钥，该密钥可由授权服务器验证。 这个密钥被称为 Code Verifier（代码验证器）。此外，调用应用程序为 Code Verifier 创建一个转换值，称为 Code Challenge ，并通过 HTTPS 发送该值（Code Challenge）去检索 Authorization Code。使用这种方法，恶意攻击者只能拦截到 Authorization Code，因为恶意攻击者没有 Code Verifier 因此无法从认证服务器获取 token。 Authorization Code 只能使用一次，并且是有时间限制的，RFC-6749 建议设置的时间为10分钟 隐含式 有些 Web 应用是纯前端应用也就是前端渲染，通过 API 数据驱动。这时就不能用授权码的方式了，必须将令牌储存在前端。RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌。这种方式没有授权码这个中间步骤，所以称为（授权码）”隐藏式”（implicit），也可以称之为授权码的简化模式， 我们还是以 Vercel 认证 Github 登录为例，来说一下这个模式的流程： * ***A***. Vercel 在登录页有可以支持 Github 登录的选项，用户选择以 Github 登录 Vercel * ***B***. 开始授权： * ***1*** -&gt; 重定向到 Github 授权页面 * ***2*** -&gt; 用户点击允许 Vercel 访问我的个人数据 * ***3***. 授权通过，Github 认证服务器将用户导向 Vercel 事先指定的**重定向URL**（Redirection URL），同时附带上授权码 * ***4***. Github 收到重定向响应后，向 Vercel 服务器表示想提取 URL 中的 Access Token * ***5***. Vercel 服务器返回带有解析脚本的页面，用于解析重定向 URL Fragment 中的 Access Token * ***6***. User-Agent 使用解析脚本，获取 Access Token * ***7***. User-Agent 将 Access Token 转交给 Vercel 此模式不生成 Refresh Token 密码式 RFC 6749 规定也允许用户把用户名和密码直接告诉该应用。该应用就使用你的账户信息申请令牌。 适用于高度信任的 Client，比如硬件设备，系统级App 客户端凭证 最后一种方式是客户端凭证（client credentials） 适用于没有前端的命令行应用，即在命令行下请求令牌，比如 Azure CLI，AWS CLI ...... 设备流 OAuth 2.0 还有一种遗留模式，Device Authorization Flow，使用受输入限制的设备连接到 Internet，而不是直接对用户进行身份验证，该设备会要求用户转到其计算机或智能手机上的链接并授权该设备。对于没有简单输入文字方式的设备，这避免了较差的用户体验。为此，设备应用程序使用设备授权流程（在 OAuth 2.0 中已批准），在设备授权流程中，它们传递其客户端 ID 来启动授权过程并获得令牌。 实践 接下来的几篇文章，我们就用 .NET Core 分别来实现这几种模式，以加深我们对 OAuth 2.0 的授权机制。","link":"/2020/11/20/oauth2/"},{"title":"OAuth 2.0 客户端凭证 - Client Credentials","text":"上一篇 OAuth 2.0 的文章中介绍了 OAuth 2.0 标准中颁发令牌的几种模式，这篇文章中将使用 .NET 5 实现客户端凭证模式（ Client Credentials ），客户端凭证模式适合于没有 GUI 的命令行应用 CLI或者M2M设备。 分析 客户端凭证模式比较简单，客户端直接通过本机凭证获取令牌，然后使用令牌访问资源服务器。 实践 ● 开发工具和环境 VSCode Postman .NET 5.0 Windows Terminal（看个人喜好，命令行工具即可） ● 创建授权服务器（Authorization Server）打开 Windows Terminal，然后输入如下命令创建一个 ASP.NET Core Empty 应用 dotnet new web -n Your-Project-Name 等待创建结束，用 VSCode 打开就可以看到这样一个项目： 紧接着安装 IdentityServer4 运行库，这是一个开源的基于 OpenID Connect 和 OAuth 2.0 标准的身份验证，单点登录和 API 访问控制框架，输入如下命令安装此运行库 dotnet add package IdentityServer4 等待运行结束，查看一下 Your-Project-Name.csproj，就可以看到已经安装的 IdentityServer4 PackageReference，我们创建一个 IdentityConfig 类用于配置授权服务器应该如何工作，新增一个 IdentityConfig.cs IdentityConfig.cs123456789101112131415161718192021222324252627282930313233343536373839404142using IdentityServer4.Models;using System.Collections.Generic;namespace AuthorizationServer{ public static class IdentityConfig { //API 资源支持和作用域的对应关系 public static IEnumerable&lt;ApiResource&gt; GetApiResources() =&gt; new ApiResource[] { new ApiResource(&quot;api1&quot;){Scopes=new[]{&quot;api1&quot;}} }; //描述提供外部选择的作用域 public static IEnumerable&lt;ApiScope&gt; GetApiScopes() =&gt; new List&lt;ApiScope&gt;() { new ApiScope(&quot;api1&quot;, &quot;Test Api 1&quot;) }; //定义客户端支持的访问规则和加密方式 public static IEnumerable&lt;Client&gt; GetClients() =&gt; new List&lt;Client&gt;() { new Client() { //客户端名称 ClientId = &quot;client1&quot;, //授权模式 - 客户端凭证 AllowedGrantTypes = GrantTypes.ClientCredentials, //客户端密钥 ClientSecrets = { new Secret(&quot;client1Secret&quot;.Sha256()) }, //允许访问的作用域 AllowedScopes = { &quot;api1&quot; } } }; }} 接下来配置一下启动管道，把配置注入进去，打开 Program.cs，找到 ConfigureServices 添加如下： 后面重点说一下 AddInMemoryApiResources 这里涉及到的一些知识 Startup.cs -> ConfigureServices12345678910111213141516171819202122public void ConfigureServices(IServiceCollection services){ ... var builder = services //添加 IdentityServer4 .AddIdentityServer() //添加作用域 .AddInMemoryApiScopes(IdentityConfig.GetApiScopes()) //添加作用域和API资源的对应关系 .AddInMemoryApiResources(IdentityConfig.GetApiResources()) //添加客户端验证配置 .AddInMemoryClients(IdentityConfig.GetClients()); if (_environment.IsDevelopment()) { //每次启动时为令牌签名创建了一个临时凭证，在生成环境中应该配置一个持久化的凭证 //生产环境应该使用如下方法添加一个持久化的凭证 //builder.AddSigningCredential(SigningCredentials) builder.AddDeveloperSigningCredential(); } ...} 启用 IdentityServer4 身份验证 Startup.cs -> Configure1234567public void Configure(IApplicationBuilder app, IWebHostEnvironment env){ ... //启用身份认证 app.UseIdentityServer(); ...} 到这里授权服务器就完成了，可以验证一下授权服务器的状态，使用 Postman 请求获取已知的配置，不过在此之前，先要添加 Dotnet Core Https 的开发证书，这样我们请求 https 的时候才不会报 The SSL connection could not be established 的错误，在授权服务器的根目录执行如下命令信任此服务证书： dotnet dev-certs https --trust 然后在控制台输入运行命令（启动以后会自动生成一个 tempkey.jwk 文件，这是自动创建的临时凭证） dotnet run 授权服务器启动以后，使用 Postman 发送一个 Get 请求验证一下服务器状态： https://localhost:5001/.well-known/openid-configuration ● 创建资源服务器（Resource Server）在授权服务器的同级目录下，创建一个资源服务器，打开 Windows Terminal，然后输入如下命令创建一个 ASP.NET Core Web API 应用 dotnet new webapi -n Your-Project-Name 创建结束后，打开项目，会看到模板自动创建了一个默认的 API，这个 API 随机返回一些天气数据。 就用这个 API 来做演示，运行之前先修改一下端口号，因为模板创建出来的都是 https:5001 和 http:5000，等一下需要同时运行授权服务器和资源服务器，不修改的话就会冲突，打开目录文件 Properties -&gt; launchSettings.json，修改 profiles -&gt; ResourceServer -&gt; applicationUrl 1&quot;applicationUrl&quot;: &quot;https://localhost:6001;http://localhost:6000&quot;, 我这里修改为了 https:6001 和 http:6000，用命令把服务跑起来，然后用 Postman 请求一下 https://localhost:6001/weatherforecast 请求没有问题，因为还没有注入身份验证，所以 API 是未受保护的状态，不需要任何认证就会响应，接下来开始注入身份认证，先安装 IdentityServer4.AccessTokenValidation 运行库： dotnet add package IdentityServer4.AccessTokenValidation 然后打开 Startup.cs，在 ConfigureServices 方法中添加如下： Startup.cs -> ConfigureServices12345678910111213141516...services.AddAuthorization();services //添加默认的 Authorization 承载头 .AddAuthentication(&quot;Bearer&quot;) //添加授权服务器配置 .AddIdentityServerAuthentication(options =&gt; { //授权服务器地址 options.Authority = &quot;https://localhost:5001&quot;; //是否必须为 https options.RequireHttpsMetadata = false; //对应在授权服务器中设置的 api 名称 options.ApiName = &quot;api1&quot;; });... 然后在 Configure 方法中启用身份验证（UseAuthentication 必须在 UseAuthorization 之前）： Startup.cs -> Configure1234...app.UseAuthentication();app.UseAuthorization();... 设置权限，添加 AuthorizeAttribute，需要 Microsoft.AspNetCore.Authorization 此命名空间。 单独为 Action 设置权限 123456[HttpGet][Authorize]public IEnumerable&lt;WeatherForecast&gt; Get(){ ...} 也可以为整个 Controller 设置权限 1234[ApiController][Route(&quot;[controller]&quot;)][Authorize]public class WeatherForecastController : ControllerBase { ... } 测试 当测试接口添加了需要认证以后，再次请求接口 https://localhost:6001/weatherforecast 会发现服务返回了 401 Unauthorized，未经授权的状态码，那是因为注入授权服务器以后，Postman 请求并没有去授权服务器拿 Access Token，没有 Access Token 所以资源服务器不会响应请求，正确的步骤是先去请求一个 Access Token，而这个过程就是客户端凭证模式，客户端通过自己的凭证去拿到令牌，然后才能成功的收到响应，我们来操作一下，两个服务都运行起来，打开到刚刚请求 API 的 Postman 页面： 选择 Authorization 标签页 1.选择 Type -&gt; OAuth 2.0 2.选择 Grant Type -&gt; Client Credentials 3.输入 Access Token URL -&gt; https://localhost:5001/connect/token （IdentityServer4 默认令牌路由） 4.输入 Client ID -&gt; client1（对应我们在授权服务器里设置 client1 授权配置） 5.输入 Client Secret -&gt; client1Secret 6.输入 Scope -&gt; api1 7.点击 Get New Access Token 点击以后，Postman 就会获取到 Authorization Token 然后应用 Token 到请求头： 再次发送请求，服务器成功响应： 扩展 - Scope 认证 看完上面的示例以后，有同学会抛出疑问了，基于 User 的 ResourceOwnerPassword 认证方式可以配置接口的角色认证，比如管理员角色可以访问管理类型的接口，普通用户角色不可以访问，那这在 IdentityServer4 中的 ClientCredential 模式中如何实现类似的功能，答案就是多客户端+Scope 认证，我们可以配置那些客户端允许访问那些 API Scope，然后在资源服务器上面去配置接口只允许此 Scope 访问，我们看一下如何操作。 ● 修改授权服务器修改授权服务器的 IdentityConfig 配置类如下： AuthorizationServer -> IdentityConfig.cs1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950using IdentityServer4.Models;using System.Collections.Generic;namespace AuthorizationServer{ public static class IdentityConfig { public static IEnumerable&lt;ApiResource&gt; GetApiResources() =&gt; new ApiResource[] { //为 api1 增加一个 scope2 资源 new ApiResource(&quot;api1&quot;){Scopes=new[]{&quot;api1&quot;, &quot;api2&quot;}}, }; public static IEnumerable&lt;ApiScope&gt; GetApiScopes() =&gt; new List&lt;ApiScope&gt;() { new ApiScope(&quot;api1&quot;, &quot;Test API 1&quot;), //增加一个 api2 scope作用域 new ApiScope(&quot;api2&quot;, &quot;Test API 2&quot;) }; public static IEnumerable&lt;Client&gt; GetClients() =&gt; new List&lt;Client&gt;() { new Client() { ClientId = &quot;client1&quot;, AllowedGrantTypes = GrantTypes.ClientCredentials, ClientSecrets = { new Secret(&quot;client1Secret&quot;.Sha256()) }, AllowedScopes = { &quot;api1&quot; } }, //增加一个客户端，允许访问 api2 scope new Client() { ClientId = &quot;client2&quot;, AllowedGrantTypes = GrantTypes.ClientCredentials, ClientSecrets = { new Secret(&quot;client2Secret&quot;.Sha256()) }, AllowedScopes = { &quot;api2&quot; } } }; }} 然后在资源服务器的 Startup.cs -&gt; ConfigureServices-&gt; AddAuthorization 方法中作如下修改： Startup.cs -> ConfigureServices-> AddAuthorization12345678910...services.AddAuthorization(options=&gt;{ //添加一个名称为 scope_client2 的规则，规则内容为：必须满足 scope 为 api2 options.AddPolicy(&quot;scope_client2&quot;, policy =&gt; { policy.RequireClaim(&quot;scope&quot;, &quot;api2&quot;); });});... 最后是修改 AuthorizeAttribute，修改如下： 单独为 Action 设置权限 123456[HttpGet][Authorize(&quot;scope_client2&quot;)]public IEnumerable&lt;WeatherForecast&gt; Get(){ ...} 也可以为整个 Controller 设置权限 1234[ApiController][Route(&quot;[controller]&quot;)][Authorize(&quot;scope_client2&quot;)]public class WeatherForecastController : ControllerBase { ... } ● 测试使用 client1 获取一个令牌 然后发送请求，会出现 403 Forbidden 修改为使用 client2 获取一个令牌 应用 token，然后发送请求，成功响应： 后言 到这里教程就结束了，前面说要重点说一下 AddInMemoryApiResources 这里涉及到的知识，在 IdentityServer4 最新版本中官方拆分了作用域和资源注册，先注册所有作用域（使用 AddInMemoryApiScopes 方法），然后再注册 API 资源（如果需要），然后 API 资源将按名称引用先前注册的范围，这里就是为什么我们在写 IdentityConfig 的时候有一个名为 GetApiResources 的方法，里头进行了这样的定义，然后再通过 AddInMemoryApiResources 添加配置 123...new ApiResource(&quot;api1&quot;){Scopes=new[]{&quot;api1&quot;}}... 因为 IdentityServer4.AccessTokenValidation 运行库默认是要验证 Audience 的，如果没有这个方法和不这样写 API 和 Scopes 之间的关系，那么生成的 Token 中就不会包含 aud 字段，而 IdentityServer4.AccessTokenValidation 默认会去解析 Audience，这样就会引发一个 IDX10214 错误 Bearer was not authenticated. Failure message: IDX10214: Audience validation failed. Audiences: 'System.String'. Did not match: validationParameters.ValidAudience: 'System.String' or validationParameters.ValidAudiences: 'System.String'. 可以做个实验，把 AddInMemoryApiResources 方法去掉，用 postman 请求一下令牌，然后把令牌复制到 jwt.ms，会发现生成的令牌是不会包含 aud 字段： 我们用这个令牌去发送请求就会得到上面的 IDX10214 错误，因为我们没有设置，所以获取到的 Audience 是空，我们还原 AddInMemoryApiResources 方法，然后重新请求一个，在复制到 jwt.ms 看一下 这样生成的令牌才是包含 aud 字段的，这样 IdentityServer4.AccessTokenValidation 去解析的时候才不会报错，重点来了，有没有办法可以不写 ApiResources 和 AddInMemoryApiResources 呢？有一个很简单的设置即可，那就是在资源服务器里头设置授权服务器配置的时候，加上 123...options.LegacyAudienceValidation = true;... 这个设置，那么授权服务器就不会校验 Audience，也不会引发 Audience 解析错误。这样就简单的演示完了，谢谢大家，更深入的知识点大家可以去看 Dotnet Core 和 IdentityServer4 的官方文档。","link":"/2020/11/21/oauth_client_credential/"},{"title":"OAuth 2.0 隐含式 - Implicit","text":"上一篇 OAuth 2.0 客户端凭证模式 的文章中使用 .NET 5 实现了客户端凭证模式，这篇文章中将将继续使用 .NET 5 实现 OAuth 2.0 隐含式（ Implicit ），隐含模式现在已经不推荐使用了，应该使用安全度更高的 Authorization Code Flow 或者 Authorization Code Flow With PKCE，现在只适合于一些对安全性要求不高的应用。 分析 隐含式通过跳转到授权中心进行用户授权，用户授权结束后，通过 Redirection URL 把 Access Token 返回到客户端托管服务器，客户端托管服务器解析 URL 回调以后传递给客户端，隐含模式适合对安全性要求不高的 SPA（Single Page Application）应用，这种方式省略了授权码（Authorization Code）这个中间步骤。 实践 ● 开发工具和环境 VSCode Postman NodeJS Vue-CLI (这一章使用 Vue 编写客户端) Yarn .NET 5.0 Windows Terminal（看个人喜好，命令行工具即可） ● 创建授权服务器（Authorization Server）打开 Windows Terminal，先安装 IdentityServer4 Template 的项目模板（因为这一章开始需要用到授权界面，为了方便所以直接使用 IdentityServer4 模板，后面会写一章如何实现自己的授权中心认证页面） dotnet new -i identityserver4.templates 等待模板安装完成，完成以后输入如下命令创建一个具有 GUI 的 Web 授权中心项目 dotnet new is4inmem -n Your-Project-Name 项目创建结束以后，先修改根目录的 Config.cs 类，修改如下： Config.cs12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273using IdentityServer4.Models;using System.Collections.Generic;using IdentityServer4.Test;namespace AuthorizationServer{ public static class Config { //可以访问的授权资源 public static IEnumerable&lt;IdentityResource&gt; IdentityResources =&gt; new IdentityResource[] { //开放ID new IdentityResources.OpenId(), //个人资料 new IdentityResources.Profile(), }; //描述提供外部选择的作用域 public static IEnumerable&lt;ApiScope&gt; ApiScopes =&gt; new ApiScope[] { new ApiScope(&quot;scope1&quot;) }; //定义客户端支持的访问规则和加密方式 public static IEnumerable&lt;Client&gt; Clients =&gt; new Client[] { new Client { //客户端ID ClientId = &quot;vue-client&quot;, //客户端名称 ClientName = &quot;Vue SPA Client&quot;, //客户端URL（稍后会使用 Vue 作为客户端，默认8080） ClientUri = &quot;http://localhost:8080&quot;, //授权模式 - 隐含式 AllowedGrantTypes = GrantTypes.Implicit, //AccessToken 是否可以通过浏览器返回 AllowAccessTokensViaBrowser = true, //是否需要用户点击同意（也就是登陆以后需要点击我允许xxx应用访问我的数据） RequireConsent = true, //重定向Url RedirectUris = { // 指定登录成功跳转回来的 Url &quot;http://localhost:8080/signin-oidc&quot;, // AccessToken 有效期比较短，刷新 AccessToken 的页面 &quot;http://localhost:8080/redirect-silent-renew&quot; }, //退出登录跳转的页面 PostLogoutRedirectUris = { &quot;http://localhost:8080/&quot; }, //允许跨域的源（因为等会的 Vue 项目和咱们的授权服务器不在一个域上） AllowedCorsOrigins = { &quot;http://localhost:8080&quot; }, //允许访问的作用域 AllowedScopes = { &quot;openid&quot;, &quot;profile&quot;, &quot;scope1&quot; } } }; //测试账户（生产环境应该指定 DbContext 以及 IResourceOwnerPasswordValidator 从数据库绑定） public static List&lt;TestUser&gt; TestUsers =&gt; new List&lt;TestUser&gt; { new TestUser { SubjectId = &quot;1&quot;, Username = &quot;test&quot;, Password = &quot;123456789&quot; } }; }} 然后修改 Startup.cs，把配置注入进去： Startup.cs -> ConfigureServices12345678910111213public void ConfigureServices(IServiceCollection services){ ... //添加授权资源 builder.AddInMemoryIdentityResources(Config.IdentityResources); //添加作用域 builder.AddInMemoryApiScopes(Config.ApiScopes); //添加客户端验证配置 builder.AddInMemoryClients(Config.Clients); //添加测试用户 builder.AddTestUsers(Config.TestUsers); ...} 到这里授权服务器就完成了，可以验证一下授权服务器的状态，使用 Postman 请求获取已知的配置，不过在此之前，先要添加 Dotnet Core Https 的开发证书，这样请求 https 的时候才不会报 The SSL connection could not be established 的错误，在授权服务器的根目录执行如下命令信任此服务证书： dotnet dev-certs https --trust 然后在控制台输入运行命令（启动以后会自动生成一个 tempkey.jwk 文件，这是自动创建的临时凭证） dotnet run 授权服务器启动以后，使用 Postman 发送一个 Get 请求验证一下服务器状态： https://localhost:5001/.well-known/openid-configuration ● 创建资源服务器（Resource Server）在授权服务器的同级目录下，创建一个资源服务器，打开 Windows Terminal，然后输入如下命令创建一个 ASP.NET Core Web API 应用 dotnet new webapi -n Your-Project-Name 创建结束后，打开项目，会看到模板自动创建了一个默认的 API，这个 API 随机返回一些天气数据。 就用这个 API 来做演示，但是简单修改一下方便后面演示做对比，如下： WeatherForecastController.cs123456789101112131415161718192021222324using Microsoft.AspNetCore.Mvc;using Microsoft.AspNetCore.Authorization;namespace ResourceServer.Controllers{ [ApiController] [Route(&quot;[controller]/{action}&quot;)] public class WeatherForecastController : ControllerBase { [HttpGet] public IActionResult TestPublic() { return Ok(new {data=&quot;Hi, this is from public api message&quot;}); } [HttpGet] [Authorize] public IActionResult TestProtected() { return Ok(new {data=&quot;Hi, this is from protected api message&quot;}); } }} 因为模板创建出来的都是 https:5001 和 http:5000，等一下需要同时运行授权服务器和资源服务器，不修改的话就会冲突，打开目录文件 Properties -&gt; launchSettings.json，修改 profiles -&gt; ResourceServer -&gt; applicationUrl 1&quot;applicationUrl&quot;: &quot;https://localhost:6001;http://localhost:6000&quot;, 我这里修改为了 https:6001 和 http:6000，用命令把服务跑起来，然后用 Postman 请求一下 https://localhost:6001/weatherforecast/testpublic 请求没有问题，因为还没有注入身份验证，所以 API 是未受保护的状态，不需要任何认证就会响应，接下来开始注入身份认证，打开 Startup.cs，在 ConfigureServices 方法中添加如下： Startup.cs -> ConfigureServices123456789101112131415161718192021222324252627282930313233...services.AddAuthorization();//添加默认的 Authorization 承载头services.AddAuthentication(&quot;Bearer&quot;).AddJwtBearer(&quot;Bearer&quot;, options =&gt;{ //授权中心地址 options.Authority = &quot;https://localhost:5001&quot;; //是否必须为 https options.RequireHttpsMetadata = false; //授权中心定义的资源名称 options.Audience = &quot;scope1&quot;; //验证客户端发过来的 Token 参数超时时间 options.TokenValidationParameters.ClockSkew = TimeSpan.FromMinutes(1); //要求 Token 需要有超时时间这个参数 options.TokenValidationParameters.RequireExpirationTime = true; //不校验 Audience options.TokenValidationParameters.ValidateAudience = false;});//配置 CORS 跨域设置services.AddCors(options =&gt;{ //规则名称 options.AddPolicy(&quot;VueClientOrigin&quot;, //vue客户端地址 builder =&gt; builder.WithOrigins(&quot;http://localhost:8080&quot;) //允许所有请求头 .AllowAnyHeader() //允许所有方法 .AllowAnyMethod());});... 然后在 Configure 方法中启用身份验证和允许跨域的规则（UseAuthentication 必须在 UseAuthorization 之前）： Startup.cs -> Configure12345...app.UseCors(&quot;VueClientOrigin&quot;);app.UseAuthentication();app.UseAuthorization();... ● 创建客户端（Client Application）打开 Windows Termianl，输入如下命令： vue create vue-client 因为用 TypeScript 写，以及 Router 定义路由，所以需要选择这两项 后面的 Vue 模板选项就看个人习惯了，项目创建结束后，安装这几个模块： oidc-client （JavaScript 的 OpenID Connect 和 OAuth2 协议客户端） promise （ES6 异步编程语法糖框架） axios （基于 Promise 的 HTTP 客户端） bootstrap-vue （bootstrap 的 Vue 版本） bootstrap-icons-vue （bootstrap 图标的 Vue 版本） 使用如下命令进行安装（axios 依赖 Promise 所以不需要额外安装）： yarn add oidc-client axios bootstrap-vue bootstrap-icons-vue -s 安装 bootstrap 的目的是为了让写出来的 Demo 更好看，安装结束后，咱们就开始正式进入客户端的编写，首先创建一个 connect 文件夹，里头创建一个 openid-connect-service.ts 服务用于连接授权服务器。 openid-connect-service.ts123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import { UserManager, User } from 'oidc-client';const vueBase = 'http://localhost:8080';const openIdConnectSettings = { //授权服务器地址 authority: 'https://localhost:5001', //授权服务器配置的客户端名称 client_id: `vue-client`, //登陆成功的重定向URL redirect_uri: `${vueBase}/signin-oidc`, //退出登录的重定向URL post_logout_redirect_uri: `${vueBase}/`, //刷新令牌的URL silent_redirect_uri: `${vueBase}/redirect-silent-renew`, //可访问的作用域 scope: 'openid profile scope1', //响应类型 response_type: `id_token token`, //自动无感刷新令牌 automaticSilentRenew: true,};//单例模式export class OpenIdConnectService { public static getInstance(): OpenIdConnectService { if (!this.instance) { this.instance = new OpenIdConnectService(); } return this.instance; } private static instance: OpenIdConnectService; //配置连接的授权服务器 private userManager = new UserManager(openIdConnectSettings); //当前用户 private currentUser!: User | undefined; private constructor() { this.userManager.clearStaleState(); this.userManager .getUser() .then((user) =&gt; { if (user) { this.currentUser = user; } else { this.currentUser = undefined; } }) .catch((err) =&gt; { this.currentUser = undefined; }); // 在建立（或重新建立）用户会话时引发 this.userManager.events.addUserLoaded((user) =&gt; { this.currentUser = user; }); // 终止用户会话时引发 this.userManager.events.addUserUnloaded(() =&gt; { this.currentUser = undefined; }); } // 当前用户是否登录 get userAvailavle(): boolean { return !!this.currentUser; } // 获取当前用户信息 get user(): User { return this.currentUser as User; } // 触发登录 public async triggerSignIn() { await this.userManager.signinRedirect(); } // 登录回调 public async handleCallback() { const user: User = await this.userManager.signinRedirectCallback(); this.currentUser = user; } // 自动刷新回调 public async handleSilentCallback() { const user: User | undefined = await this.userManager.signinSilentCallback(); this.currentUser = user; } // 退出登录 public async triggerSignOut() { await this.userManager.signoutRedirect(); }} 然后在 src 添加一个 services 文件夹，往里面添加一个 resource-service.ts 用于访问测试资源服务器。 resource-service.ts1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import axios, { AxiosResponse, AxiosRequestConfig } from 'axios';import { OpenIdConnectService } from '@/connect/openid-connect-service';const oidc: OpenIdConnectService = OpenIdConnectService.getInstance();const baseHost = 'https://localhost:6001';export const Apis = { Testpublic: `${baseHost}/WeatherForecast/TestPublic`, Testprotected: `${baseHost}/WeatherForecast/TestProtected`,};export interface Result { data: string;}export const PublicApi = (): Promise&lt;Result&gt; =&gt; { return new Promise&lt;Result&gt;(async (resolve, reject) =&gt; { try { const requestConfig: AxiosRequestConfig = { url: Apis.Testpublic }; const res: AxiosResponse&lt;Result&gt; = await axios(requestConfig); resolve(res.data); } catch (e) { reject(e); } });};export const ProtectedApi = (): Promise&lt;Result&gt; =&gt; { return new Promise&lt;Result&gt;(async (resolve, reject) =&gt; { try { const requestConfig: AxiosRequestConfig = { url: Apis.Testprotected, headers: { Authorization: GetAuth() }, }; const res: AxiosResponse&lt;Result&gt; = await axios(requestConfig); resolve(res.data); } catch (e) { reject(e); } });};const GetAuth = (): string =&gt; { let auth: string = ``; if (oidc.user &amp;&amp; oidc.user.token_type &amp;&amp; oidc.user.access_token) { auth = `${oidc.user.token_type} ${oidc.user.access_token}`; } return auth;}; 授权服务器和资源服务器的 service 就完成了，接下来就是编写 views 了，首先是欢迎界面，在 views 下面添加一个 Welcome.vue 组件 Welcome.vue1234567891011121314151617181920212223242526272829303132333435363738394041&lt;template&gt; &lt;div&gt; &lt;b-icon font-scale=&quot;8.5&quot; icon=&quot;shield-lock-fill&quot; variant=&quot;danger&quot; class=&quot;mb-4&quot;&gt;&lt;/b-icon&gt; &lt;h2 class=&quot;mb-4&quot;&gt;.NET Core Implicit Flow Auth&lt;/h2&gt; &lt;b-button-group vertical class=&quot;w-25&quot;&gt; &lt;b-button variant=&quot;danger&quot; @click=&quot;signiClick&quot; class=&quot;mb-2&quot;&gt;Sign-ni&lt;/b-button&gt; &lt;b-button variant=&quot;success&quot; @click=&quot;publicClick&quot; class=&quot;mb-2&quot;&gt;Call Public API&lt;/b-button&gt; &lt;b-button @click=&quot;protectedClick&quot; class=&quot;mb-2&quot;&gt;Call Protected API&lt;/b-button&gt; &lt;/b-button-group&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt; import { Component, Vue, Inject } from 'vue-property-decorator'; import { OpenIdConnectService } from '@/connect/openid-connect-service'; import { PublicApi, ProtectedApi } from '@/services/resource-service'; @Component export default class Welcome extends Vue { @Inject() private oidc!: OpenIdConnectService; private signiClick() { console.log('oidc', this.oidc.userAvailavle, this.oidc); if (!this.oidc.userAvailavle) { this.oidc.triggerSignIn(); } else { this.$router.push({ path: '/home' }); } } private async publicClick() { const resultData = await PublicApi(); console.log(resultData); } private async protectedClick() { const resultData = await ProtectedApi(); console.log(resultData); } }&lt;/script&gt; 然后是 SigninOidc.vue 组件，这个是登陆成功后跳转回调的页面（也就是比如某些网站用 QQ 登陆以后会出现登陆成功，正在为您跳转回原站点） SigninOidc.vue123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;h1&gt;Login Succuess, callback, waiting&lt;/h1&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt; import { Component, Vue, Inject } from 'vue-property-decorator'; import { OpenIdConnectService } from '@/connect/openid-connect-service'; @Component export default class SigninOidc extends Vue { @Inject() private oidc!: OpenIdConnectService; public async created() { await this.oidc.handleCallback(); this.$router.push({ path: '/home' }); } }&lt;/script&gt; 然后是 RedirectSilentRenew.vue 组件，这个组件是自动刷新令牌用的 RedirectSilentRenew.vue1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt; import { Component, Vue, Inject } from 'vue-property-decorator'; import { OpenIdConnectService } from '@/connect/openid-connect-service'; @Component export default class RedirectSilentRenew extends Vue { @Inject() private oidc!: OpenIdConnectService; public created() { this.oidc.handleSilentCallback(); }}&lt;/script&gt; 最后修改 Home.vue 组件，这个是登陆成功以后重定向页面导航过来的目标页面。 Home.vue123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;div&gt; &lt;b-icon font-scale=&quot;8.5&quot; icon=&quot;patch-check-fll&quot; variant=&quot;success&quot; class=&quot;mb-4&quot;&gt;&lt;/b-icon&gt; &lt;h2 class=&quot;mb-4&quot;&gt;Login Successfully&lt;/h2&gt; &lt;b-button-group vertical class=&quot;w-25&quot;&gt; &lt;b-button variant=&quot;danger&quot; @click=&quot;signOutClick&quot; class=&quot;mb-2&quot;&gt;Sign-out&lt;/b-button&gt; &lt;b-button variant=&quot;success&quot; @click=&quot;publicClick&quot; class=&quot;mb-2&quot;&gt;Call Public API&lt;/b-button&gt; &lt;b-button variant=&quot;success&quot; @click=&quot;protectedClick&quot; class=&quot;mb-2&quot;&gt;Call Protected API&lt;/b-button&gt; &lt;/b-button-group&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt; import { Component, Vue, Inject } from 'vue-property-decorator'; import { OpenIdConnectService } from '@/connect/openid-connect-service'; import { PublicApi, ProtectedApi } from '@/services/resource-service'; @Component export default class Welcome extends Vue { @Inject() private oidc!: OpenIdConnectService; private async created() { if (!this.oidc.userAvailavle) { await this.oidc.triggerSignIn(); } } private async signOutClick() { await this.oidc.triggerSignOut(); } private async publicClick() { const resultData = await PublicApi(); console.log(resultData); } private async protectedClick() { const resultData = await ProtectedApi(); console.log(resultData); } }&lt;/script&gt; 这样所有的视图组件就写完了，接下来修改一下 App.vue 完善一下样式以及授权服务器的初始化 App.vue123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div id=&quot;main&quot;&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view/&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt; import { Component, Vue, Provide } from 'vue-property-decorator'; import { OpenIdConnectService } from './connect/openid-connect-service'; @Component export default class App extends Vue { @Provide() private oidc: OpenIdConnectService = OpenIdConnectService.getInstance(); }&lt;/script&gt;&lt;style&gt;html, body { height: 100%;}#main { height: 100%; width: 100%; display: table;}#app { display: table-cell; height: 100%; vertical-align: middle; text-align: center;}&lt;/style&gt; 然后修改一下路由，找到 router 文件夹下的 index.ts，修改成如下： index.ts12345678910111213141516171819202122232425262728293031323334import Vue from 'vue';import VueRouter, { RouteConfig } from 'vue-router';Vue.use(VueRouter);const routes: Array&lt;RouteConfig&gt; = [ { path: '/', name: 'welcome', component: () =&gt; import('../views/Welcome.vue'), }, { path: '/home', name: 'home', component: () =&gt; import('../views/Home.vue'), }, { path: '/signin-oidc', name: 'signin-oidc', component: () =&gt; import('../views/SigninOidc.vue'), }, { path: '/redirect-silent-renew', name: 'redirect-silent-renew', component: () =&gt; import('../views/RedirectSilentRenew.vue'), },];const router = new VueRouter({ mode: 'history', routes,});export default router; 最后在 main.ts 中启用 bootstrap 和 bootstrap-icons 组件，以及装饰路由器 main.ts123456789101112131415import Vue from 'vue';import App from './App.vue';import router from './router';import { BootstrapVue, BootstrapVueIcons } from 'bootstrap-vue';import 'bootstrap/dist/css/bootstrap.css';import 'bootstrap-vue/dist/bootstrap-vue.css';Vue.use(BootstrapVue);Vue.use(BootstrapVueIcons);Vue.config.productionTip = false;new Vue({ router, render: (h) =&gt; h(App),}).$mount('#app'); 最后修改一下 ESlint 的语法校验 .eslintrc.js，把大小写驼峰检测关掉，以及缩进，要不然编译会出现错误，这是因为 oidc-client 的配置属性使用了 小写+下划线。 .eslintrc.js12345678910module.exports = { ... rules: { ... 'camelcase': [2, {'properties': 'always'}], 'no-mixed-spaces-and-tabs': 'off' ... } ...} 到这里客户端也编写完成了，接下来就是测试了。 测试 首先把三个项目都运行起来（授权服务器，资源服务器，客户端）： 授权服务器和资源服务器运行命令 dotnet run 客户端运行命令 yarn serve 然后访问一下客户端 可以看到，不登录之前没有授权保护的 Public API 是可以请求通过的，但是 Protected API 因为有授权保护，所以不登陆之前都是返回 401，登陆以后就可以请求通过了，登陆的时候会跳转到授权中心页面进行授权，用户同意 vue client 访问以后，就会跳转回我们的客户端页面，如果通过 URL 直接访问受保护的路由，也会触发自动登录。","link":"/2020/11/23/oauth_implicit_flow/"},{"title":"优雅改写 Node Modules","text":"对于一直在使用 Hexo 框架构建博客的同学来说肯定有这方面那方面定制化 Hexo 框架的需求，那么这就涉及到需要修改 Hexo 的模块文件，也就是 Node Modules，常规的修改手段可能是拷贝一份到自己的项目，然后手动修改 package.json 里头的引用依赖，这种方式短时间看好像没什么问题，部署到生产环境也可以运行，但是长时间来看，暴漏的问题就很多了，你可能只修改了一个文件，甚至几行，但是却要付出很大的版本代价。 版本代价源于你无法跟随包的版本更新而自动更新，需要手动得再来一次相同的操作，有同学可能会说了，我自己写一个脚本完成这个流水线工作，没有错，思路非常正确，这也就是今天要介绍的强大模块 - Patch Modules。 这个模块也是完成了这样一个自动化的流水线工作，不过它的工作方式不是全量的，而是基于 diff 差异化更新。 Patch-Package 工作模式 * 1.安装此模块 * 2.修改需要定制化的模块 * 3.运行 Patch-Package 的命令，生成 patch 差异文件 * 4.修改 package.json 的 Script，使其运行 npm install 的时候自动部署差异到模块库 实践 我的需求来自需要修改 Hexo 博客框架的类别标签排列，因为我的博客类别列表是这样的： 但是我觉得不太好看，因为我的项目列表有三个子项（公司项目，外包项目，个人项目），这种有子类别的放到中间就不太好看，我希望把这种有子类别的放到后面去，查看源码，发现了生成博客类别列表的 node modules 模块，然后就可以用 Patch Modules 操作一下了。 安装 Patch Package npm i patch-package --save-dev 修改 Node Modules 修改 Hexo 模块，这里就不贴我的代码了，没有什么参考意义。 运行 Patch Package 命令 修改完成后，运行如下命令生成 patch 文件： npx patch-package your-package-name 运行结束后，就会看到项目的根目录里头生成了 patches 文件夹，里头有这样一个文件 your-package-name+version.patch 运行 Package.json 文件 修改 package.json 的 Script，使其运行 npm install 的时候自动部署差异到模块库 123456789{ ... &quot;scripts&quot;: { ... &quot;postinstall&quot;: &quot;patch-package&quot; ... } ...} 重新安装模块 修改完成后，如果直接运行 npm install 或者 npm install –force，都会出现错误，Patch Package 会提示你删除掉 node_modules 文件夹以后重试，我们按照他说的要求删除以后，重新运行 npm install –no-save，就会出现成功提示。 然后重新运行 hexo server 命令，重新查看博客，就会看到修改已经生效了","link":"/2020/11/09/patch_package/"},{"title":"API接口逆向思路 - 拼多多篇","text":"为不触及同行利益，本篇博客只提供思路，并且单一的了解此博客内容也无法产生利益，不提供可运行代码。 前段时间有个客户找我做一个和拼多多相关的业务，重点询问了我一个有关拼多多接口的问题，我因为比较忙，所以没帮他写，但是提供了一个思路给他，接下来我们一起看看这个问题。 做过拼多多接口逆向或者其他平台（比如德州仪器，耐克）逆向的同学，可能对 API 的校验非常了解，常规 API 除了最容易获得的 Token 以外，Request Header 中还会附加一些其他的自定义内容用来加强保护 API 强度，比如最出名的是 Akamai 公司的 Sensor_data, 这个 request 属性中包含的内容堪称变态，大概有鼠标轨迹，浏览器指纹，canvas 指纹，SSL 指纹，时间戳算法，键盘动作等等，能逆向成功并且通过 Akamai 检测的同学可以说已经是行业顶级了。那接下来我们一起看看拼多多的防范手段。 我们随便进入一个拼多多的页面，然后查看开发者工具你会看到这样一个东西。 除了这个 Anti-Content 之外，其他所有的认证头信息都非常容易获得，所以此篇博客都是围绕这个东西开始叙述思路，因为其他的请求信息不需要教，你也可以轻松获得。 废话不多说，开始进入 spy 环节，经常逆向 API 的同学肯定非常清楚第一步当然是点开调用链开始我们的奇幻之旅。 可以看到这个请求经过了四个不同的 JS 文件，最终完成了这个请求。 使用过 react，vue 或者 angular 开发并且使用 webpack 打包过的同学肯定知道， **chunk**和文件名为 GUID 的这两种 JS 文件，一般都是 node*modules 的模块打包，不包含业务代码，基本都是一些第三方库和框架代码，所以我们只需要从 commons.*.js 这文件下手 点开调用链第一次经过 commons.*.js 的地方，开发者工具帮我们自动定位到这个片段。 不要犹豫，打上断点，然后刷新页面重新请求一下。 可以看到此时 request headers 还没有附加 Anti-Content ,继续调用链往上找。 使用同样的方法点开第二个调用链经过的地方，并且打上断点。 可以看到返回了一个 Promise，因为 Promise 是一个异步语法糖，所以这里没啥用，继续按照相同的办法往调用顶上走，使用老套路打上断点，一直重复这个动作，最后发现。 是这里产生了 Anti_Content，那就很简单了，我们把产生的中间段代码跟踪一下就知道是怎么产生的，然后就是漫长的阅读和 Debugging 时间，做过 API 逆向的同学肯定知道，这个过程非常痛苦，轻则十几分钟出结果，重则几天没有结果，因为 JS 打包后的文件非常变态，变量名全是 a,b,c,d 之类的，并且为了兼容浏览器版本，JavaScript 全部都是 es moudule（是的，就是你经常 F12 看到的那一堆和乱码一样的代码），但是还好，只是 1 个小时左右就找到了，这里非常考验你的经验，熟练的同学会非常快，具体过程就不多说了，此篇博客只提供思路。 这里产生了这个 Anti_Content，我们可以测试一下，打开浏览器 Console，然后输入这个函数。 非常好，检验没问题，那接下来就非常考验你对于 web 开发的专业知识掌握和底层的理解，你此时要考虑这几个问题： 1.如何提取 webpack 打包的代码片段。 2.如何提取 ”提取到的 webpack 代码片段” 中的这段函数。 3.如何在任何编程语言中运行这段函数？（因为你可能使用任何语言编写爬虫和自动化软件） 我们开始一步步攻克，首先你要知道 webpack 是什么，以及 babel 是如何把代码编译成浏览器所兼容的 JS，所以你的第一步就是把打包后的代码通过 babel 还原成打包前的，你需要知道 webpack 打包的 JS 脚本会分为加载器和执行器（执行器就是刚刚我们一直跟踪的那个 JS 文件），通常加载器和执行器是一对多的。 然后你需要用 nodejs 写一个这样的 ast 还原代码，大概长这样（不提供源码，只提供思路）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import * as parser from &quot;@babel/parser&quot;;import * as t from &quot;@babel/types&quot;;import * as generator from &quot;@babel/generator&quot;;import traverse from &quot;@babel/traverse&quot;;import * as fs from &quot;fs&quot;;function wtofile(path: string, flags: string, code: string): void { const fd = fs.openSync(path, flags); fs.writeSync(fd, code); fs.closeSync(fd);}function run(loader_path: string, out_path: string, modular_path: string): void { // 读取加载器文件 const js_code: string = fs.readFileSync(loader_path, { encoding: &quot;utf-8&quot; }); // 将代码转化为 AST 语法树 const loader_ast = parser.parse(js_code); // 获取加载器代码 let loader_body: any; // 注意：这里暂时将 loader_body 的类型设置为 any if (loader_ast.program.body[0].expression.type === 'UnaryExpression') { loader_body = loader_ast.program.body[0].expression.argument.callee.body.body; } else { loader_body = loader_ast.program.body[0].expression.callee.body.body; } let export_function: string | null = null; // 遍历 AST 查找导出函数 traverse(loader_ast, { FunctionDeclaration(path: any) { if (path.toString().includes(&quot;exports:&quot;) &amp;&amp; export_function === null) { export_function = path.node.id.name; } } }); //中间省略 20240321 个字。。。 // 导入加载器中的函数体 let loader_arguments: any; // 注意：这里暂时将 loader_arguments 的类型设置为 any if (loader_ast.program.body[0].expression.type === 'UnaryExpression') { loader_arguments = loader_ast.program.body[0].expression.argument.arguments[0]; } else { loader_arguments = loader_ast.program.body[0].expression.arguments[0]; } // 在全局范围声明导出函数变量 loader_ast.program.body.splice(0, 0, t.variableDeclaration(&quot;var&quot;, [t.variableDeclarator(t.identifier(&quot;export_function&quot;))]));} 将此转化器保存为 reverseAst.ts（个人习惯，倾向于使用 Typescript），然后使用 tsc 编译成 reverseAst.js，然后把 webpack 的加载器和我们跟踪的 JS 文件从拼多多服务器上下载下来，然后使用我们写的这个脚本开始提取，这样就可以提取 webpack 打包的代码了。 成功输出 prot.js 文件。 然后回到第二个问题，怎么提取那个产生 Anti_Content 的函数片段，答案就是无解，只能自己一行行看。 在 prot.js 中向上查找，找 oe 是怎么来的，a 方法是怎么来的，这里就不细说了，只能靠你自己悟了。 可以看到 oe 是 r.n(mt) 来的，然后 mt 又是 r(“fbeZ”) 来的，先找到 fbeZ，如图： 一行行找到以后，你就可以编写自己的自己的代码了，当然你还需要补全浏览器环境才行（不提供源码，只提供思路）。 然后编写代码片段。 最后执行，大功告成。 然后附加到 postman 请求一下。 请求成功响应，没有附加 Anti_Content 的请求是无法通过拼多多服务器的校验的，会返回 Error。","link":"/2024/03/20/pdd-api/"}],"tags":[{"name":"Dotnet","slug":"Dotnet","link":"/tags/Dotnet/"},{"name":"Avalonia","slug":"Avalonia","link":"/tags/Avalonia/"},{"name":"CSharp","slug":"CSharp","link":"/tags/CSharp/"},{"name":"WPF","slug":"WPF","link":"/tags/WPF/"},{"name":"Notify","slug":"Notify","link":"/tags/Notify/"},{"name":"Consul","slug":"Consul","link":"/tags/Consul/"},{"name":"Gnome","slug":"Gnome","link":"/tags/Gnome/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Blazor","slug":"Blazor","link":"/tags/Blazor/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"Grub","slug":"Grub","link":"/tags/Grub/"},{"name":"Prism","slug":"Prism","link":"/tags/Prism/"},{"name":"Project","slug":"Project","link":"/tags/Project/"},{"name":"QT","slug":"QT","link":"/tags/QT/"},{"name":"CPP","slug":"CPP","link":"/tags/CPP/"},{"name":"Rainmeter","slug":"Rainmeter","link":"/tags/Rainmeter/"},{"name":"Lua","slug":"Lua","link":"/tags/Lua/"},{"name":"Trojan","slug":"Trojan","link":"/tags/Trojan/"},{"name":"VPS","slug":"VPS","link":"/tags/VPS/"},{"name":"VPN","slug":"VPN","link":"/tags/VPN/"},{"name":"Shell","slug":"Shell","link":"/tags/Shell/"},{"name":"Typora","slug":"Typora","link":"/tags/Typora/"},{"name":"Script","slug":"Script","link":"/tags/Script/"},{"name":"VSCode","slug":"VSCode","link":"/tags/VSCode/"},{"name":"MVVM","slug":"MVVM","link":"/tags/MVVM/"},{"name":"AOP","slug":"AOP","link":"/tags/AOP/"},{"name":"XAML","slug":"XAML","link":"/tags/XAML/"},{"name":"Xamarin","slug":"Xamarin","link":"/tags/Xamarin/"},{"name":"CLI","slug":"CLI","link":"/tags/CLI/"},{"name":"gRpc","slug":"gRpc","link":"/tags/gRpc/"},{"name":"WebAssembly","slug":"WebAssembly","link":"/tags/WebAssembly/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"CI&#x2F;CD","slug":"CI-CD","link":"/tags/CI-CD/"},{"name":"Travis","slug":"Travis","link":"/tags/Travis/"},{"name":"OAuth","slug":"OAuth","link":"/tags/OAuth/"},{"name":"NodeJS","slug":"NodeJS","link":"/tags/NodeJS/"},{"name":"API","slug":"API","link":"/tags/API/"}],"categories":[{"name":".NET","slug":"NET","link":"/categories/NET/"},{"name":"WPF","slug":"WPF","link":"/categories/WPF/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"NodeJS","slug":"NodeJS","link":"/categories/NodeJS/"},{"name":"Prism","slug":"Prism","link":"/categories/Prism/"},{"name":"Project","slug":"Project","link":"/categories/Project/"},{"name":"QT","slug":"QT","link":"/categories/QT/"},{"name":"Script","slug":"Script","link":"/categories/Script/"},{"name":"Web","slug":"Web","link":"/categories/Web/"},{"name":"CI&#x2F;CD","slug":"CI-CD","link":"/categories/CI-CD/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}]}